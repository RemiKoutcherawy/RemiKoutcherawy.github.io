<html lang="fr">
<head>
<link>
  <meta charset="UTF-8"/>
  <title>OriSim3D en JavaScript</title>
  <style>
    body { display:block; margin:5px;}
    #height100 { position:relative; width:100%; height:100%;}
    #canvas3d { position:absolute; width:100%; height:100%; left:0%; top:0; border:1px solid darkblue;}
    #canvas3dtext { position:absolute; width:100%; height:100%; left:0%; top:0; z-index:10; }
  </style>
</head>
<body>
  <div class="height100">
    <canvas id="canvas3d"></canvas>
    <canvas id="canvas3dtext"></canvas>
  </div>

  <img style="display: none" id="back" src="data:image/jpeg;base64,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"/>
  <img style="display: none" id="front" src="data:image/jpeg;base64,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"/>

</body>
<script id="cocotte" type="not-javascript">
// Cocotte
d -200 200 -200 -200 200 -200 200 200
// Marque les médianes et diagonales
c 0 1 c 0 3 c 0 2 c 1 3
// Marque les demi-bords
c 0 8 c 8 3 c 0 4 c 4 1
// Marque les coins
c 6 0 c 6 1 c 6 2 c 6 3
// Retourne iad interpolateur accelerate decelerate
iad
t 500 ty 180)
// Replie le coin et retourne
t 1000 r 48 180 21 0 10)
o 1 24 0 7 25
t 500 ty 180)
// Bord haut
t 500 r 37 179 8 17 3)
t 500 r 55 90 17 3 a 3 19)
// Côté droit
t 500 r 29 179 5 22 2 a 19 3 17)
t 500 r 54 -45 19 3 17)
t 100 r 55 -30 17 a 3)
// Oreille bas
t 500 r 53 -90 22 2 a 18)
t 500 r 45 178 1 12 7 a 18 2 22 )
t 100 r 53 -20 22 a 18 2)
t 500 r 53 -70 18 2 22 a 22 )
// Oreille bas gauche
t 500 r 50 -90 12 1 a 24)
t 500 r 23 178 4 a 24 1 12 )
t 100 r 50 -80 12 1 24)
// Replie en ouvrant le bec
t 500 r 16 -90 10 8 20 17 16 14 3 19 r 40 -90 0)
t 500 r 16 -80 10 8 20 17 16 14 3 19 a 0)
// Ajuste à peu près
r 44 -10 4 r 44 -5 7
r 29 -5 5 r 29 -10 8
// a 12
// Montre
iao t 1000 zf) t 1000 tz -45) t 1000 zf)
iso t 4000 ty 360) igb
end
</script>

<script type="application/javascript">
  // File:src/Point.js
  // Point to hold Points
  // 3D : x y z
  // Flat crease pattern : xf, yf
  function Point(xf, yf, x, y, z) {
    this.debug = false;

    // Create new Point(x,y,z)
    if (arguments.length === 3) {
      if (this.debug){console.log("Point 3D:"+xf+" "+yf+" "+x+" "+y+" "+z);}
      // x y z 3D
      this.x  = xf;
      this.y  = yf;
      this.z  = x;
      // x y Flat, in unfolded state
      this.xf = xf;
      this.yf = yf;
      return this;
    }
    // Create new Point(xf,yf)
    else if (arguments.length === 2) {
      if (this.debug){console.log("Point 2D:"+xf+" "+yf+" "+x+" "+y+" "+z);}
      // x y Flat, in unfolded state
      this.xf = xf;
      this.yf = yf;
      // x y z 3D
      this.x  = xf;
      this.y  = yf;
      this.z  = 0;
      return this;
    }
    // Create with new Point(xf,yf, x,y,z)
    else {
      if (this.debug){console.log("Point 5D:"+xf+" "+yf+" "+x+" "+y+" "+z);}
      // x y Flat, in unfolded state
      this.xf = 0 | xf;
      this.yf = 0 | yf;
      // x y z 3D
      this.x  = 0 | x;
      this.y  = 0 | y;
      this.z  = 0 | z;
    }
    if (this.debug){console.log("Point:"+this.xf+" "+this.yf+" "+this.x+" "+this.y+" "+this.z);}
    return this;
  }

  // Class methods
  Point.prototype = {
    constructor:Point,
    // Set x y Flat and  x y z 3D
    set5d:function (xf, yf, x, y, z) {
      if (this.debug){console.log("set5d:"+xf+" "+yf+" "+x+" "+y+" "+z);}
      // x y Flat, in unfolded state
      this.xf = 0 | xf;
      this.yf = 0 | yf;
      // x y z 3D
      this.x  = 0 | x;
      this.y  = 0 | y;
      this.z  = 0 | z;
    },
    // Set x y z 3D
    set3d:function (x, y, z) {
      if (this.debug){console.log("set3d:"+x+" "+y+" "+z);}
      this.x = 0 | x;
      this.y = 0 | y;
      this.z = 0 | z;
    },
    // Set x y z 2D
    set2d:function (xf, yf) {
      if (this.debug){console.log("set3d:"+xf+" "+yf);}
      this.xf = 0 | xf;
      this.yf = 0 | yf;
    },
    // Sqrt(this.this)
    length:function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    // Scale
    scale:function (t) {
      this.x *= t;
      this.y *= t;
      this.z *= t;
      return this;
    },
    // Normalize as a vector
    norm:function () {
      let lg = this.length();
      return this.scale(1.0 / lg);
    },

    // String representation
    toString:function () {
      return "[" + Math.round(this.x) + "," + Math.round(this.y) + "," + Math.round(this.z)
        + "  " + Math.round(this.xf) + "," + Math.round(this.yf) + "]";
    },
    // Short String representation
    toXYZString:function () {
      return "[" + Math.round(this.x) + "," + Math.round(this.y) + "," + Math.round(this.z) + "]";
    },
    // Short String representation
    toXYString:function () {
      return "[" + Math.round(this.xf) + "," + Math.round(this.yf) + "]";
    }
  };

  // Static methods
  // Dot a with b
  Point.dot = function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
  };
  // New Vector A + B
  Point.add = function add(A, B) {
    return new Point(A.x + B.x, A.y + B.y, A.z + B.z);
  };
  // New Vector A - B
  Point.sub = function sub(A, B) {
    return new Point(A.x - B.x, A.y - B.y, A.z - B.z);
  };
  // Return 0 if Point is near x,y,z
  Point.compare3d = function compare3D(p1, p2, y, z) {
    if (arguments.length === 2) {
      // compare3D (p1, p2)
      let dx2 = (p1.x - p2.x) * (p1.x - p2.x);
      let dy2 = (p1.y - p2.y) * (p1.y - p2.y);
      let dz2 = (p1.z - p2.z) * (p1.z - p2.z);
      let d   = dx2 + dy2 + dz2;
      return d > 1 ? d : 0;
    } else {
      // compare3D (p1, x,y,z)
      let dx2 = (p1.x - p2) * (p1.x - p2);
      let dy2 = (p1.y - y) * (p1.y - y);
      let dz2 = (p1.z - z) * (p1.z - z);
      let d   = dx2 + dy2 + dz2;
      return d > 1 ? d : 0;
    }
  };
  // Return 0 if Point is near xf,yf
  Point.compare2d = function compare2D(p1, p2) {
    let dx2 = (p1.xf - p2.xf) * (p1.xf - p2.xf);
    let dy2 = (p1.yf - p2.yf) * (p1.yf - p2.yf);
    return Math.sqrt(dx2 + dy2);
  };

  // File: js/Plane.js
  // Plane is defined by an origin point R and a normal vector N
  // a point P is on plane iff RP.N = 0
  function Plane(r, n) {
    this.r = r;
    this.n = n;
  }

  // Static values
  Plane.THICKNESS = 1;

  // Static methods
  // Define a plane across 2 points
  Plane.across = function (p1, p2) {
    let middle = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);
    let normal = new Point(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
    return new Plane(middle, normal);
  };
  // Plane by 2 points along Z
  Plane.by     = function (p1, p2) {
    let r = new Point(p1.x, p1.y, p1.z);
    // Cross product P2P1 x 0Z
    let n = new Point(p2.y - p1.y, -(p2.x - p1.x), 0);
    return new Plane(r, n);
  };
  // Plane orthogonal to Segment and passing by Point
  Plane.ortho  = function (s, p) {
    let r      = new Point(p.x, p.y, p.z);
    let normal = new Point(s.p2.x - s.p1.x, s.p2.y - s.p1.y, s.p2.z - s.p1.z);
    return new Plane(r, normal);
  };

  // Class methods
  Plane.prototype = {
    isOnPlane:function (p) {
      // Point P is on plane iff RP.N = 0
      let rp = Point.sub(p, this.r);
      let d  = Point.dot(rp, this.n);
      return (Math.abs(d) < 0.1);
    },
    // Intersection of This plane with segment defined by two points
    intersectPoint:function (a, b) {
      // (A+tAB).N = d <=> t = (d-A.N)/(AB.N) then Q=A+tAB 0<t<1
      let ab  = new Point(b.x - a.x, b.y - a.y, b.z - a.z);
      let abn = Point.dot(ab, this.n);
      // segment parallel to plane
      if (abn === 0)
        return null;
      // segment crossing
      let t = (Point.dot(this.r, this.n) - Point.dot(a, this.n)) / abn;
      if (t >= 0 && t <= 1.0)
        return Point.add(a, ab.scale(t));
      return null;
    },
    // Intersection of This plane with Segment Return Point or null
    intersectSeg:function (s) {
      // (A+tAB).N=d <=> t=(d-A.N)/(AB.N) then Q=A+tAB 0<t<1
      let ab  = new Point(s.p2.x - s.p1.x, s.p2.y - s.p1.y, s.p2.z - s.p1.z);
      let abn = Point.dot(ab, this.n);
      if (abn === 0)
        return null;
      let t = (Point.dot(this.r, this.n) - Point.dot(s.p1, this.n)) / abn;
      if (t >= 0 && t <= 1.0)
        return Point.add(s.p1, ab.scale(t));
      return null;
    },
    // Classify point to thick plane 1 in front 0 on -1 behind
    classifyPointToPlane:function (p) {
      // (A+tAB).N = d <=> d<e front, d>e behind, else on plane
      let dist = Point.dot(this.r, this.n) - Point.dot(this.n, p);
      if (dist > Plane.THICKNESS)
        return 1;
      if (dist < -Plane.THICKNESS)
        return -1;
      return 0;
    },
    // toString
    toString:function () {
      return "Pl[r:" + this.r + " n:" + this.n + "]";
    }
  };

  // File: js/Segment.js
  // Segment to hold Segments : Two points p1 p2
  function Segment (p1, p2, type) {
    this.p1        = p1;
    this.p2        = p2;
    this.type      = Segment.PLAIN | type;
    this.lg2d = this.length2d();
    this.lg3d = this.length3d();
    this.angle     = 0;
    this.highlight = false;
  }
  // Static values
  Segment.PLAIN     = 0;
  Segment.EDGE      = 1;
  Segment.MOUNTAIN  = 2;
  Segment.VALLEY    = 3;
  Segment.TEMPORARY = -1;
  Segment.EPSILON   = 0.01;

  // Class methods
  Segment.prototype = {
    constructor:Segment,
    // Reverse order of the 2 points of this segment
    reverse:function () {
      const p   = this.p1;
      this.p1 = this.p2;
      this.p2 = p;
    },
    // 3D Length in space
    length3d:function () {
      this.lg3d = Math.sqrt((this.p1.x - this.p2.x) * (this.p1.x - this.p2.x)
        + (this.p1.y - this.p2.y) * (this.p1.y - this.p2.y)
        + (this.p1.z - this.p2.z) * (this.p1.z - this.p2.z));
      return this.lg3d;
    },
    // 2D Length in flat view
    length2d:function () {
      this.lg2d = Math.sqrt(
        (this.p1.xf - this.p2.xf) * (this.p1.xf - this.p2.xf)
        + (this.p1.yf - this.p2.yf) * (this.p1.yf - this.p2.yf));
      return this.lg2d;
    },
    // String representation
    toString:function () {
      return "S(P1:"+this.p1.toXYZString()+" "+this.p1.toXYString()+", P2:"+this.p2.toXYZString()+" "+this.p2.toXYString()+")";
      // +" type:"+this.type+" angle:"+this.angle
      // +" 2d:"+this.lg2d+" 3d:"+this.lg3d+" "
      // +" L="+faceLeft+" R="+faceRight+")";
    }
  };

  // Static methods
  // Compares segments s1 with s2
  Segment.compare = function (s1, s2) {
    let d = Point.compare3d(s1.p1, s2.p1) + Point.compare3d(s2.p2, s2.p2);
    return d > 1 ? d : 0;
  };
  // 2D Distance between Segment and Point @testOK
  Segment.distanceToSegment = function (seg, pt) {
    let x1 = seg.p1.x;
    let y1 = seg.p1.y;
    let x2 = seg.p2.x;
    let y2 = seg.p2.y;
    let x = pt.x;
    let y = pt.y;
    let l2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    let r = ((y1 - y) * (y1 - y2) + (x1 - x) * (x1 - x2)) / l2;
    let s = ((y1 - y) * (x2 - x1) - (x1 - x) * (y2 - y1)) / l2;
    let d = 0;
    if (r <= 0) {
      d = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    } else if (r >= 1) {
      d = Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));
    } else {
      d = (Math.abs(s) * Math.sqrt(l2));
    }
    return d;
  };
  // Closest points from s1 to s2 returned as a new segment
  Segment.closestSeg = function closestSeg(s1, s2) {
    // On this segment we have : S1(t1)=p1+t1*(p2-p1)       = p1+t1*v1   = p
    // On v argument we have   : S2(t2)=v.p1+t2*(v.p2-v.p1) = s2.p2+t2*v2 = q
    // Vector pq perpendicular to both lines : pq(t1,t2).v1=0  pq(t1,t2).v2=0
    // Cramer system :
    // (v1.v1)*t1 - (v1.v2)*t2 = -v1.r <=> a*t1 -b*t2 = -c
    // (v1.v2)*t1 - (v2.v2)*t2 = -v2.r <=> b*t1 -e*t2 = -f
    // Solved to t1=(bf-ce)/(ae-bb) t2=(af-bc)/(ae-bb)
    let t1;
    let t2;
    // s1 direction
    let v1 = new Point(s1.p2.x - s1.p1.x, s1.p2.y - s1.p1.y, s1.p2.z - s1.p1.z);
    // s2 direction
    let v2 = new Point(s2.p2.x - s2.p1.x, s2.p2.y - s2.p1.y, s2.p2.z - s2.p1.z);
    // s2.p1 to s1.p1
    let r = new Point(s1.p1.x - s2.p1.x, s1.p1.y - s2.p1.y, s1.p1.z - s2.p1.z);
    let a = Point.dot(v1,v1); // squared length of s1
    let e = Point.dot(v2,v2); // squared length of s2
    let f = Point.dot(v2,r);  //
    // Check degeneration of segments into points
    if (a <= Segment.EPSILON && e <= Segment.EPSILON) {
      // Both degenerate into points
      t1 = t2 = 0.0;
      return new Segment(s1.p1, s2.p1, Segment.TEMPORARY);
    }
    if (a <= Segment.EPSILON) {
      // This segment degenerate into point
      t1 = 0.0;
      t2 = f / e; // t1=0 => t2 = (b*t1+f)/e = f/e
      t2 = t2 < 0 ? 0 : t2 > 1 ? 1 : t2;
    } else {
      let c = Point.dot(v1, r);
      if (e <= Segment.EPSILON) {
        // Second segment degenerate into point
        t2 = 0.0;
        t1 = -c / a; // t2=0 => t1 = (b*t2-c)/a = -c/a
        t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
      } else {
        // General case
        let b = Point.dot(v1, v2); // Delayed computation of b
        let denom = a * e - b * b; // Denominator of Cramer system
        // Segments not parallel, compute closest and clamp
        if (denom !== 0.0) {
          t1 = (b * f - c * e) / denom;
          t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
        }
        else {
          // Arbitrary point, here 0 => p1
          t1 = 0;
        }
        // Compute closest on L2 using
        t2 = (b * t1 + f) / e;
        // if t2 in [0,1] done, else clamp t2 and recompute t1
        if (t2 < 0.0) {
          t2 = 0;
          t1 = -c / a;
          t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
        }
        else if (t2 > 1.0) {
          t2 = 1.0
          ;
          t1 = (b - c) / a;
          t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
        }
      }
    }
    let c1 = Point.add(s1.p1, v1.scale(t1)); // c1 = p1+t1*(p2-p1)
    let c2 = Point.add(s2.p1, v2.scale(t2)); // c2 = p1+t2*(p2-p1)
    return new Segment(c1, c2);
  };
  // Closest points from s1(line) to s2(line) returned as a new segment
  Segment.closestLine = function closestLine(s1, s2) {
    // On s1 segment we have : S1(t1)=p1+t1*(p2-p1)       = p1+t1*v1   = p
    // On s2 segment we have : S2(t2)=v.p1+t2*(v.p2-v.p1) = s2.p2+t2*v2 = q
    // Vector pq perpendicular to both lines : pq(t1,t2).v1=0  pq(t1,t2).v2=0
    // Cramer system :
    // (v1.v1)*t1 - (v1.v2)*t2 = -v1.r <=> a*t1 -b*t2 = -c
    // (v1.v2)*t1 - (v2.v2)*t2 = -v2.r <=> b*t1 -e*t2 = -f
    // Solved to t1=(bf-ce)/(ae-bb) t2=(af-bc)/(ae-bb)
    let t1;
    let t2;
    let v1 = new Point(s1.p2.x - s1.p1.x, s1.p2.y - s1.p1.y, s1.p2.z - s1.p1.z); // s1 direction
    let v2 = new Point(s2.p2.x - s2.p1.x, s2.p2.y - s2.p1.y, s2.p2.z - s2.p1.z); // s direction
    let r = new Point(s1.p1.x - s2.p1.x, s1.p1.y - s2.p1.y, s1.p1.z - s2.p1.z); // s2.p1 to s1.p1
    let a = Point.dot(v1, v1); // squared length of s1
    let e = Point.dot(v2, v2); // squared length of s
    let f = Point.dot(v2, r);  //
    // Check degeneration of segments into points
    if (a <= Segment.EPSILON && e <= Segment.EPSILON) {
      // Both degenerate into points
      t1 = t2 = 0.0;
      return new Segment(s1.p1, s2.p1, Segment.TEMPORARY, -1);
    }
    if (a <= Segment.EPSILON) {
      // This segment degenerate into point
      t1 = 0.0;
      t2 = f / e; // t1=0 => t2 = (b*t1+f)/e = f/e
    } else {
      let c = Point.dot(v1, r);
      if (e <= Segment.EPSILON) {
        // Second segment degenerate into point
        t2 = 0.0;
        t1 = -c / a; // t2=0 => t1 = (b*t2-c)/a = -c/a
      } else {
        // General case
        let b = Point.dot(v1, v2); // Delayed computation of b
        let denom = a * e - b * b; // Denominator of cramer system
        // Segments not parallel, compute closest
        if (denom !== 0.0) {
          t1 = (b * f - c * e) / denom;
        }
        else {
          // Arbitrary point, here 0 => p1
          t1 = 0;
        }
        // Compute closest on L2 using
        t2 = (b * t1 + f) / e;
      }
    }
    let c1 = Point.add(s1.p1, v1.scale(t1)); // c1 = p1+t1*(p2-p1)
    let c2 = Point.add(s2.p1, v2.scale(t2)); // c2 = p1+t2*(p2-p1)
    return new Segment(c1, c2);
  };

  // File: js/Face.js
  // Face contains points, segments, normal
  function Face() {
    this.points    = [];
    this.normal    = [0, 0, 1];
    this.select    = 0;
    this.highlight = false;
    this.offset    = 0;
  }
  // Static values

  // Class methods
  Face.prototype = {
    constructor: Face,

    // Compute Face normal
    computeFaceNormal: function () {
      if (this.points.length < 3) {
        console.log("Warn Face < 3pts:" + this);
        return null;
      }
      for (let i = 0; i < this.points.length - 2; i++) {
        // Take triangles until p2p1 x p1p3 > 0.1
        let p1         = this.points[i];
        let p2         = this.points[i + 1];
        let p3         = this.points[i + 2];
        let u          = [p2.x - p1.x, p2.y - p1.y, p2.z - p1.z];
        let v          = [p3.x - p1.x, p3.y - p1.y, p3.z - p1.z];
        this.normal[0] = u[1] * v[2] - u[2] * v[1];
        this.normal[1] = u[2] * v[0] - u[0] * v[2];
        this.normal[2] = u[0] * v[1] - u[1] * v[0];
        if (Math.abs(this.normal[0]) + Math.abs(this.normal[1]) + Math.abs(this.normal[2]) > 0.1) {
          break;
        }
      }
      this.normalize(this.normal);
      return this.normal;
    },

    // Normalize vector v[3] = v[3]/||v[3]||
    normalize: function (v) {
      let d = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
      v[0] /= d;
      v[1] /= d;
      v[2] /= d;
    },

    // String representation
    toString: function () {
      let str = "F" + "(";
      this.points.forEach(function (p, i, a) {
        str = str + "P" + i + p.toString()+ (i === a.length - 1 ? "": " ");
      });
      str = str + ")";
      return str;
    }
  };

  // File: js/Model.js
  // Model to hold Points, Segments, Faces
  function Model() {
    // Arrays to hold points, faces, segments
    this.points   = [];
    this.segments = [];
    this.faces    = [];
    this.debug = false;
  }

  // Class methods
  Model.prototype = {
    constructor:Model,

    // Initializes this orModel with XY points CCW @testOK
    init:function (list) {
      this.points   = [];
      this.segments = [];
      this.faces    = [];
      this.change   = true;
      let f         = new Face();
      // Add XY XYZ points, make EDGE segments
      let p1        = null;
      for (let i = 0; i < list.length; i += 2) {
        let p2 = this.addPointXYZ(list[i], list[i + 1], list[i], list[i + 1], 0);
        f.points.push(p2);
        if (p1 !== null) {
          this.addSegment(p1, p2, Segment.EDGE);
        }
        p1 = p2;
      }
      this.addSegment(p1, f.points[0], Segment.EDGE);
      this.addFace(f);
      return this;
    },
    // Adds a point to this Model or return the point at x,y @testOK
    addPointXYZ: function (xf,yf, x,y,z) {
      // Create a new Point
      let p = null;
      if (arguments.length === 2) {
        p = new Point(xf, yf);
      } else if (arguments.length === 3) {
        p = new Point(x, y, z);
      } else if (arguments.length === 5) {
        p = new Point(xf, yf, x, y, z);
      } else {
        console.log("Warn wrong number of Args for addPointXYZ")
      }
      this.points.push(p);
      return p;
    },
    // Adds a point to this Model or return existing point @testOK
    addPoint:function (pt) {
      // Search existing points
      for (let i = 0; i < this.points.length; i++) {
        if (Point.compare3d(this.points[i], pt) < 1) {
          // Return existing point instead of pt parameter
          return this.points[i];
        }
      }
      // Add new Point if not already in model
      this.points.push(pt);
      //this.change = true;
      return pt;
    },
    // Adds a segment to this model @testOK
    addSegment:function (p1, p2, type) {
      if (Point.compare3d(p1, p2) === 0) {
        console.log("Warn Add degenerate segment:" + p1);
        console.log(new Error().stack);
        return null;
      }
      let s = new Segment(p1, p2, type);
      this.segments.push(s);
      //this.change = true;
      return s;
    },
    // Adds a face to this model @testOK
    addFace:function (f) {
      // TODO search existing faces
      this.faces.push(f);
      //this.change = true;
      return f;
    },
    // Align Point p on segment s in 2D from coordinates in 3D @testOK
    align2dFrom3d:function (p, s) {
      // Compute the length from p1 to p in 3D
      let lg3d = Math.sqrt((s.p1.x - p.x) * (s.p1.x - p.x)
        + (s.p1.y - p.y) * (s.p1.y - p.y)
        + (s.p1.z - p.z) * (s.p1.z - p.z));
      // Compute ratio with the segment length
      let t    = lg3d / s.length3d();
      // Set 2D to have the same ratio
      p.xf     = s.p1.xf + t * (s.p2.xf - s.p1.xf);
      p.yf     = s.p1.yf + t * (s.p2.yf - s.p1.yf);
    },
    // Find face on the right of segment a b @testOK
    faceRight:function (a, b) {
      if (b === undefined) {
        // Guess we have a segment instead of two points
        b = a.p2;
        a = a.p1;
      }
      let ia    = 0, ib = 0;
      let right = null;
      this.faces.forEach(function (f) {
        // Both points are in face
        if (((ia = f.points.indexOf(a)) >= 0)
          && ((ib = f.points.indexOf(b)) >= 0)) {
          // a is after b, the face is on the right
          if (ia === ib + 1 || (ib === f.points.length - 1 && ia === 0)) {
            right = f;
          }
        }
      });
      return right;
    },
    // Find face on the left @testOK
    faceLeft:function (a, b) {
      if (b === undefined) {
        // Guess we have a segment instead of two points
        b = a.p2;
        a = a.p1;
      }
      let ia, ib;
      let left = null;
      this.faces.forEach(function (f) {
        // Both points are in face
        if (((ia = f.points.indexOf(a)) >= 0)
          && ((ib = f.points.indexOf(b)) >= 0)) {
          // b is after a, the face is on the left
          if (ib === ia + 1 || (ia === f.points.length - 1 && ib === 0)) {
            left = f;
          }
        }
      });
      return left;
    },
    // Search face containing a and b but which is not f0 @testOK
    searchFace:function (s, f0) {
      let a     = s.p1;
      let b     = s.p2;
      let found = null;
      this.faces.forEach(function (f) {
        if (f0 === null
          && (f.points.indexOf(a) > -1)
          && (f.points.indexOf(b) > -1)) {
          found = f;
        }
        else if (f !== f0
          && (f.points.indexOf(a)) > -1
          && (f.points.indexOf(b) > -1)) {
          found = f;
        }
      });
      return found;
    },

    // Compute angle between face left and right of a segment, angle is positive  @testOK
    computeAngle:function (s) {
      let a     = s.p1;
      let b     = s.p2;
      // Find faces left and right
      let left  = this.faceLeft(a, b);
      let right = this.faceRight(a, b);
      // Compute angle in Degrees at this segment
      if (s.type === Segment.EDGE) {
        console.log("Warn Angle on Edge:" + s);
        console.log(new Error().stack);
        return 0;
      }
      if (right === null || left === null) {
        console.log("Warn No right and left face for:" + s + " left:" + left + " right:" + right);
        console.log(new Error().stack);
        return 0;
      }
      let nL  = left.computeFaceNormal();
      let nR  = right.computeFaceNormal();
      // Cross product nL nR
      let cx  = nL[1] * nR[2] - nL[2] * nR[1], cy = nL[2] * nR[0] - nL[0] * nR[2], cz = nL[0] * nR[1] - nL[1] * nR[0];
      // Segment vector
      let vx  = s.p2.x - s.p1.x, vy = s.p2.y - s.p1.y, vz = s.p2.z - s.p1.z;
      // Scalar product between segment and cross product, normed
      let sin = (cx * vx + cy * vy + cz * vz) /
        Math.sqrt(vx * vx + vy * vy + vz * vz);
      // Scalar between normals
      let cos = nL[0] * nR[0] + nL[1] * nR[1] + nL[2] * nR[2];
      if (cos > 1.0)
        cos = 1.0;
      if (cos < -1.0)
        cos = -1.0;
      s.angle = Math.acos(cos) / Math.PI * 180.0;
      if (Number.isNaN(s.angle)) {
        s.angle = 0.0;
      }
      if (sin < 0)
        s.angle = -s.angle;
      // Follow the convention folding in front is positive
      s.angle = -s.angle;
      return s.angle;
    },
    // Search segment containing Points a and b @testOK
    searchSegmentTwoPoints:function (a, b) {
      let list = [];
      this.segments.forEach(function (s) {
        if ((Point.compare3d(s.p1, a) === 0 && Point.compare3d(s.p2, b) === 0)
          ||(Point.compare3d(s.p2, a) === 0 && Point.compare3d(s.p1, b) === 0) )
          list.push(s);
      });
      if (list.length > 1) {
        console.log("Error More than one segment on 2 points:" + list.length
          + " " + list[0].p1 + list[0].p2 + " " + list[1].p1 + list[1].p2);
        console.log(new Error().stack);
      }
      if (list.length === 0)
        return null;
      return list[0];
    },
    // Search segments containing Point a @testOK
    searchSegmentsOnePoint:function (a) {
      let list = [];
      this.segments.forEach(function (s) {
        if (s.p1 === a || s.p2 === a)
          list.push(s);
      });
      return list;
    },

    // Splits Segment by a point @testOK
    splitSegmentByPoint:function (s, p) {
      // No new segment if on ending point
      if (Point.compare3d(s.p1, p) === 0 || Point.compare3d(s.p2, p) === 0) {
        return s;
      }
      // Create new Segment
      let s1 = this.addSegment(p, s.p2, s.type);
      // Shorten s
      s.p2   = p;
      s.length2d();
      s.length3d();
      return s1;
    },
    // Split segment on a point, add point to model, update faces containing segment @testOK
    splitSegmentOnPoint:function (s1, p) {
      // Align Point p on segment s in 2D from coordinates in 3D
      this.align2dFrom3d(p, s1);
      // Add point P to first face.
      let l = this.searchFace(s1, null);
      if (l !== null && l.points.indexOf(p) === -1) {
        // Add after P2 or P1 for the left face (CCW)
        let pts = l.points;
        for (let i = 0; i < pts.length; i++) {
          if (pts[i] === s1.p1
            && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p2) {
            pts.splice(i + 1, 0, p);
            break;
          }
          if (pts[i] === s1.p2
            && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p1) {
            pts.splice(i + 1, 0, p);
            break;
          }
        }
      }
      // Add point P to second face.
      let r = this.searchFace(s1, l);
      if (r !== null && r.points.indexOf(p) === -1) {
        let pts = r.points;
        // Add after P2 or P1 for the right face (CCW)
        for (let i = 0; i < pts.length; i++) {
          if (pts[i] === s1.p1 && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p2) {
            pts.splice(i + 1, 0, p);
            break;
          }
          if (pts[i] === s1.p2 && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p1) {
            pts.splice(i + 1, 0, p);
            break;
          }
        }
      }
      // Add this as a new point to the model
      this.addPoint(p);
      // Now we can shorten s to p
      this.splitSegmentByPoint(s1, p);
      return s1;
    },
    // Splits Segment by a ratio k in  ]0 1[ counting from p1 @testOK
    splitSegmentByRatio:function (s, k) {
      // Create new Point
      let p = new Point();
      p.set3d(
        s.p1.x + k * (s.p2.x - s.p1.x),
        s.p1.y + k * (s.p2.y - s.p1.y),
        s.p1.z + k * (s.p2.z - s.p1.z));
      this.splitSegmentOnPoint(s, p);
    },

    // Origami
    // Split Face f by plane pl @testOK except on <:> denerate poly
    // Complex by design
    splitFaceByPlane:function (f1, pl) {
      if (this.debug){console.log("Face:"+this.faces.indexOf(f1)+" "+f1);}
      if (this.debug){console.log("Plane:"+pl);}
      let front     = []; // Front side
      let back      = []; // Back side
      let inFront   = false; // Front face with at least one point
      let inBack    = false;  // Back face with at least one point
      let lastinter = null; // Last intersection

      // Begin with last point
      let a     = f1.points[f1.points.length - 1];
      let aSide = pl.classifyPointToPlane(a);
      for (let n = 0; n < f1.points.length; n++) {
        // Segment from previous 'a'  to current 'b'
        // 9 cases : behind -1, on 0, in front +1
        // Push to front and back
        //  	  a  b Inter front back
        // c1) -1  1 i     i b   i    bf
        // c2)  0  1 a     b     .    of
        // c3)  1  1 .     b     .    ff
        // c4)  1 -1 i     i     i b  fb
        // c5)  0 -1 a     .     a b  ob ??
        // c6) -1 -1 .           b    bb
        // c7)  1  0 b     b     .    fo
        // c8)  0  0 a b   b     .    oo
        // c9) -1  0 b     b     b    bo
        let b     = f1.points[n];
        let bSide = pl.classifyPointToPlane(b);
        if (bSide === 1) {    // b in front
          if (aSide === -1) { // a behind
            // c1) b in front, a behind => edge cross bf
            let j = pl.intersectPoint(b, a);
            // Add i to model points
            let i = this.addPoint(j);
            // Add 'i' to front and back sides
            front.push(i);
            back.push(i);
            // Examine segment a,b to split (can be null if already split)
            let s     = this.searchSegmentTwoPoints(a, b);
            let index = this.segments.indexOf(s);
            if (index !== -1) {
              // Set i 2D coordinates from 3D
              this.align2dFrom3d(i, s);
              if(this.debug){console.log(" Add Seg ib:"+index+" a:"+a+" b:"+b+" i:"+i);}
              // Add new segment
              this.addSegment(i, b, Segment.PLAIN);
              // Modify existing set b = i
              // this.segments.splice(index, 1); has drawback
              if (s.p1 === a) {
                s.p2 = i;
              }
              else {
                s.p1 = i;
              }
            }
            // Eventually add segment from last intersection
            if (lastinter !== null) {
              if(this.debug){console.log(" Add Seg ii last:"+lastinter+" a:"+a+" b:"+b+" i:"+i);}
              this.addSegment(lastinter, i, Segment.PLAIN);
              lastinter = null;
            } else {
              lastinter = i;
            }
            if(this.debug){console.log("  c1 bf:"+a+" "+b+" i:"+i);}
          }
          else if (aSide === 0) {
            // c2) 'b' in front, 'a' on
            lastinter = a;
            if(this.debug){console.log("  c2 of:"+" "+a+" "+b);}
          }
          else if (aSide === 1) {
            // c3) 'b' in front 'a' in front
            if(this.debug){console.log("  c3 ff:"+a+" "+b);}
          }
          // In all 3 cases add 'b' to front side
          front.push(b);
          inFront = true;
        }
        else if (bSide === -1) {  // b behind
          if (aSide === 1) {        // a in front
            // c4) edge cross add intersection to both sides
            let j = pl.intersectPoint(b, a);
            // Add i to model points
            let i = this.addPoint(j);
            // Add 'i' to front and back sides
            front.push(i);
            back.push(i);
            // Examine segment a,b to split
            let s     = this.searchSegmentTwoPoints(a, b);
            let index = this.segments.indexOf(s);
            if (index !== -1) {
              // Set i 2D coordinates from 3D
              this.align2dFrom3d(i, s);
              // Add new segment
              this.addSegment(i, b, Segment.PLAIN);
              // Modify existing
              // this.segments.splice(index, 1); has drawback
              if (s.p1 === a) {
                s.p2 = i;
              } else {
                s.p1 = i;
              }
            }
            // Eventually add segment from last inter
            if (lastinter !== null && i !== lastinter) {
              if(this.debug){console.log(" Add Seg ii last:"+lastinter+" a:"+a+" b:"+b+" i:"+i);}
              this.addSegment(lastinter, i);
              lastinter = null;
            } else {
              lastinter = i;
            }
            if(this.debug){console.log("  c4 fb:"+a+" "+b+" i:"+i);}
          }
          else if (aSide === 0) {
            // c5) 'a' on 'b' behind
            if (back[back.length - 1] !== a){
              back.push(a);
            }
            // Eventually add segment from last inter
            if (lastinter !== null && lastinter !== a) {
              if(this.debug){console.log(" Add Seg ia last:"+lastinter+" a:"+a+" b:"+b+" =="+(lastinter !== a));}
              this.addSegment(lastinter, a, Segment.PLAIN);
              lastinter = null;
            } else {
              lastinter = a;
            }
            if(this.debug){console.log("  c5 ob:"+a+" "+b);}
            if(this.debug){console.log("     back:"+back);}
          }
          else if (aSide === -1) {
            // c6) 'a' behind 'b' behind
            if(this.debug){console.log("  c6 bb:"+a+" "+b);}
          }
          // In all 3 cases add current point 'b' to back side
          back.push(b);
          inBack = true;
        }
        else if (bSide === 0) {   // b on
          if (aSide === 1) {
            // c7) 'a' front 'b' on
            if(this.debug){console.log("  c7 fo:"+a+" "+b);}
          }
          if (aSide === 0) {
            // c8) 'a' on 'b' on
            if(this.debug){console.log("  c8 oo:"+a+" "+b);}
          }
          if (aSide === -1) {       // a behind
            // c9 'a' behind 'b' on
            back.push(b);
            // Eventually add segment from last inter
            if (lastinter !== null && lastinter !== b) {
              let s = this.searchSegmentTwoPoints(lastinter, b);
              if(this.debug){console.log(" Add Seg lastb last:"+lastinter+" a:"+a+" b:"+b+" s:"+s+" ==:"+(lastinter !== b));}
              if (s === null) {
                this.addSegment(lastinter, b, Segment.PLAIN);
              }
              lastinter = null;
            } else {
              lastinter = b;
            }
            if(this.debug){console.log("  c9 bo:"+a+" "+b);}
            if(this.debug){console.log("     back:"+back);}
          }
          // In all 3 cases, add 'b' to front side
          front.push(b);
        }
        // Next edge
        a     = b;
        aSide = bSide;
      }
      if(this.debug){console.log("exit back:"+back);}
      // Modify initial face f1 and add new face if not degenerated
      // this.faces.splice(this.faces.indexOf(f1), 1); change Array
      if (inFront) {
        f1.points = front;
        f1        = null;
      }
      if (inBack) {
        if (f1 !== null) {
          f1.points = back;
        } else {
          let f    = new Face();
          f.points = back;
          this.faces.push(f);
          //this.change = true;
        }
      }
    },
    // Split all or given Faces by a plane @testOK
    splitFacesByPlane:function (pl, list) {
      // Split list or all faces
      list = (list !== undefined) ? list : this.faces;
      if (this.debug){console.log("faces.length:"+this.faces.length)}
      // When a face is split, one face is modified in Array and one added, at the end
      for (let i = list.length - 1; i > -1; i--) {
        let f = list[i];
        this.splitFaceByPlane(f, pl);
      }
    },
    // Split all or given faces Across two points @testOK
    splitCross:function (p1, p2, list) {
      let pl = Plane.across(p1, p2);
      this.splitFacesByPlane(pl, list);
    },
    // Split all or given faces By two points @testOK
    splitBy:function (p1, p2, list) {
      let pl = Plane.by(p1, p2);
      this.splitFacesByPlane(pl, list);
    },
    // Split faces by a plane Perpendicular to a Segment passing by a Point "p" @testOK
    splitOrtho:function (s, p, list) {
      let pl = Plane.ortho(s, p);
      this.splitFacesByPlane(pl, list);
    },
    // Split faces by a plane between two segments given by 3 points p1 center @testOK
    splitLineToLineByPoints:function (p0, p1, p2, list) {
      // Project p0 on p1 p2
      let p0p1 = Math.sqrt((p1.x - p0.x) * (p1.x - p0.x)
        + (p1.y - p0.y) * (p1.y - p0.y)
        + (p1.z - p0.z) * (p1.z - p0.z));
      let p1p2 = Math.sqrt((p1.x - p2.x) * (p1.x - p2.x)
        + (p1.y - p2.y) * (p1.y - p2.y)
        + (p1.z - p2.z) * (p1.z - p2.z));
      let k    = p0p1 / p1p2;
      let x    = p1.x + k * (p2.x - p1.x);
      let y    = p1.y + k * (p2.y - p1.y);
      let z    = p1.z + k * (p2.z - p1.z);
      // e is on p1p2 symmetric of p0
      let e    = new Point(x, y, z);
      // Define Plane
      let pl   = Plane.by(p0, e);
      this.splitFacesByPlane(pl, list);
    },
    // Split faces by a plane between two segments @testOK
    splitLineToLine:function (s1, s2, list) {
      let s = Segment.closestLine(s1, s2);
      if (s.length3d() < 1) {
        // Segments cross at c Center
        let c = s.p1;
        let a = Point.sub(s1.p1, c).length() > Point.sub(s1.p2, c).length() ? s1.p1 : s1.p2;
        let b = Point.sub(s2.p1, c).length() > Point.sub(s2.p2, c).length() ? s2.p1 : s2.p2;
        this.splitLineToLineByPoints(a, c, b, list);
      } else {
        // Segments do not cross, parallel
        let pl = Plane.across(s.p1, s.p2);
        this.splitFacesByPlane(pl, list);
      }
    },

    // Rotate around axis Segment by angle a list of Points @testOK
    rotate:function (s, angle, list) {
      let angleRd = angle * Math.PI / 180.0;
      let ax      = s.p1.x, ay = s.p1.y, az = s.p1.z;
      let nx      = s.p2.x - ax, ny = s.p2.y - ay, nz = s.p2.z - az;
      let n       = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
      nx *= n;
      ny *= n;
      nz *= n;
      let sin     = Math.sin(angleRd), cos = Math.cos(angleRd);
      let c1      = 1.0 - cos;
      let c11     = c1 * nx * nx + cos, c12 = c1 * nx * ny - nz * sin, c13 = c1 * nx * nz + ny * sin;
      let c21     = c1 * ny * nx + nz * sin, c22 = c1 * ny * ny + cos, c23 = c1 * ny * nz - nx * sin;
      let c31     = c1 * nz * nx - ny * sin, c32 = c1 * nz * ny + nx * sin, c33 = c1 * nz * nz + cos;
      list.forEach(function (p) {
        let ux = p.x - ax, uy = p.y - ay, uz = p.z - az;
        p.x    = ax + c11 * ux + c12 * uy + c13 * uz;
        p.y    = ay + c21 * ux + c22 * uy + c23 * uz;
        p.z    = az + c31 * ux + c32 * uy + c33 * uz;
      });
      //this.change = true;
    },
    // Turn model around axis by  angle @testOK
    turn:function (axe, angle) {
      if(this.debug){console.log("axe:"+axe+" angle:"+angle);}
      angle *= Math.PI / 180.0;
      let ax = 0, ay = 0, az = 0;
      let nx = 0.0;
      let ny = 0.0;
      let nz = 0.0;
      if (axe === 1) {
        nx = 1.0;
      }
      else if (axe === 2) {
        ny = 1.0;
      }
      else if (axe === 3) {
        nz = 1.0;
      }
      let n   = (1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz));
      nx *= n;
      ny *= n;
      nz *= n;
      let sin = Math.sin(angle);
      let cos = Math.cos(angle);
      let c1  = 1.0 - cos;
      let c11 = c1 * nx * nx + cos, c12 = c1 * nx * ny - nz * sin, c13 = c1 * nx * nz + ny * sin;
      let c21 = c1 * ny * nx + nz * sin, c22 = c1 * ny * ny + cos, c23 = c1 * ny * nz - nx * sin;
      let c31 = c1 * nz * nx - ny * sin, c32 = c1 * nz * ny + nx * sin, c33 = c1 * nz * nz + cos;
      this.points.forEach(function (p) {
        let ux = p.x - ax, uy = p.y - ay, uz = p.z - az;
        p.x    = ax + c11 * ux + c12 * uy + c13 * uz;
        p.y    = ay + c21 * ux + c22 * uy + c23 * uz;
        p.z    = az + c31 * ux + c32 * uy + c33 * uz;
      });
    },

    // Adjust one Point on its (eventually given) segments @testOK
    adjust:function (p, segments) {
      // Take all segments containing point p or given list
      let segs = segments || this.searchSegmentsOnePoint(p);
      if (this.debug){console.log("segs:"+segs);}
      let dmax = 100;
      // Kaczmarz or Verlet
      // Iterate while length difference between 2d and 3d is > 1e-3
      for (let i = 0; dmax > 0.001 && i < 20; i++) {
        dmax = 0;
        // Iterate over all segments
        // Pm is the medium point
        let pm = new Point(0, 0, 0);
        for (let j = 0; j < segs.length; j++) {
          let s = segs[j];
          let lg3d = s.length3d();
          let lg2d = s.length2d(); // Should not change
          let d    = (lg2d - lg3d);
          if (Math.abs(d) > dmax) {
            dmax = Math.abs(d);
          }
          // Move B Bnew = A + AB * r With r = l2d/l3d
          // AB * r is the extension based on length3d to match length2d
          let r = (lg2d / lg3d);
          if (s.p2 === p) {
            // move p2
            pm.x += s.p1.x + (s.p2.x - s.p1.x) * r;
            pm.y += s.p1.y + (s.p2.y - s.p1.y) * r;
            pm.z += s.p1.z + (s.p2.z - s.p1.z) * r;
          } else if (s.p1 === p) {
            // move p1
            pm.x += s.p2.x + (s.p1.x - s.p2.x) * r;
            pm.y += s.p2.y + (s.p1.y - s.p2.y) * r;
            pm.z += s.p2.z + (s.p1.z - s.p2.z) * r;
          }
        }
        // Set Point with average position taking all segments
        if (segs.length !== 0) {
          p.x = pm.x / segs.length;
          p.y = pm.y / segs.length;
          p.z = pm.z / segs.length;
        }
      }
      return dmax;
    },
    // Adjust list of Points @testOK
    adjustList:function (list) {
      let dmax = 100;
      for (let i = 0; dmax > 0.001 && i < 100; i++) {
        dmax     = 0;
        for (let j = 0; j < list.length; j++) {
          let p = list[j];
          let segs = this.searchSegmentsOnePoint(p);
          let d = this.adjust(p, segs);
          if (Math.abs(d) > dmax) {
            dmax = Math.abs(d);
          }
        }
      }
      return dmax;
    },

    // Evaluate and highlight segments with wrong length
    evaluate:function () {
      let dmax = 0;
      let smax = null;
      // Iterate over all segments
      for (let i = 0; i < this.segments.length; i++) {
        let s = this.segments[i];
        let d = Math.abs(s.length2d() - s.length3d());
        if (d < 0.1) {
          s.highlight = false;
        } else {
          s.highlight = true;
        }
      }
    },
    // Select (highlight) points
    selectPts:function (pts) {
      //for (let p in pts)
      pts.forEach(function (p) {
        p.select ^= true; // xor
      });
    },
    // Select (highlight) segments
    selectSegs:function (segs) {
      segs.forEach(function (s) {
        s.select ^= true; // xor
      });
    },

    // Move list of points by dx,dy,dz
    move:function (dx, dy, dz, pts) {
      pts = (pts === null) ? this.points : ((pts.length === 0) ? this.points : pts);
      pts.forEach(function (p) {
        p.x += dx;
        p.y += dy;
        p.z += dz;
      });
    },
    // Move on a point P0 all following points, k from 0 to 1 for animation
    moveOn:function (p0, k1, k2, pts) {
      pts.forEach(function (p) {
        p.x = p0.x * k1 + p.x * k2;
        p.y = p0.y * k1 + p.y * k2;
        p.z = p0.z * k1 + p.z * k2;
      });
    },
    // Move on a line S0 all following points, k from 0 to 1 for animation
    moveOnLine:function (s, k1, k2, pts) {
      pts.forEach(function (p) {
        // Point n = s0.closestLine(new Segment(p,p)).p1;
        // First case if there is a segment joining point p and s search point common pc
        let pc = null;
        let pd = null;
        this.segments.some(function (si) {
          if (si.equals(p, s.p1)) {
            pc = si.p2;
            pd = s.p2;
            return true;
          } else if (si.equals(p, s.p2)) {
            pc = si.p2;
            pd = s.p1;
            return true;
          } else if (si.equals(s.p1, p)) {
            pc = si.p1;
            pd = s.p2;
            return true;
          } else if (si.equals(s.p2, p)) {
            pc = si.p1;
            pd = s.p1;
            return true;
          }
        });
        // if we have pc point common and pd point distant
        if (pc !== null) {
          // Turn p on pc pd (keep distance from Pc to P)
          let pcp  = Math.sqrt((pc.x - p.x) * (pc.x - p.x)
            + (pc.y - p.y) * (pc.y - p.y)
            + (pc.z - p.z) * (pc.z - p.z));
          let pcpd = Math.sqrt((pc.x - pd.x) * (pc.x - pd.x)
            + (pc.y - pd.y) * (pc.y - pd.y)
            + (pc.z - pd.z) * (pc.z - pd.z));
          let k    = pcp / pcpd;
          p.x      = (pc.x + k * (pd.x - pc.x)) * k1 + p.x * k2;
          p.y      = (pc.y + k * (pd.y - pc.y)) * k1 + p.y * k2;
          p.z      = (pc.z + k * (pd.z - pc.z)) * k1 + p.z * k2;
        }
        // Second case
        else {
          // console.log("Second case"); Oui ça arrive sur le bateau
          // Project point
          let pp = s.closestLine(new Segment(p, p)).p1;
          // Move point p on projected pp
          p.x    = (p.x + (pp.x - p.x)) * k1 + p.x * k2;
          p.y    = (p.y + (pp.y - p.y)) * k1 + p.y * k2;
          p.z    = (p.z + (pp.z - p.z)) * k1 + p.z * k2;
        }
      }, this);
    },
    // Move given or all points to z = 0
    flat:function (pts) {
      let lp = pts.length === 0 ? this.points : pts;
      lp.forEach(function (p) {
        p.z = 0;
      });
    },
    // Offset by dz all following faces according to Z
    offset:function (dz, lf) {
      if(this.debug){console.log("offset:"+dz+" lf:"+lf.length);}
      lf.forEach(function (f) {
        f.offset += dz;
      });
    },
    // // Offset all faces either behind zero plane or above zero plane
    // offsetDecal:function (dcl, list) {
    //   list    = list.length === 0 ? this.faces : list;
    //   let max = dcl < 0 ? -1000 : 1000;
    //   let o   = 0;
    //   list.forEach(function (f) {
    //     f.computeFaceNormal();
    //     o = f.offset * (f.normal[2] >= 0 ? 1 : -1);
    //     if (dcl < 0 && o > max) max = o;
    //     if (dcl > 0 && o < max) max = o;
    //   });
    //   list.forEach(function (f) {
    //     f.offset -= (max - dcl) * (f.normal[2] >= 0 ? 1 : -1);
    //   });
    // },
    // // Add offset dz to all following faces according to Z
    // offsetAdd:function (dz, list) {
    //   let lf = list.length === 0 ? this.faces : list;
    //   lf.forEach(function (f) {
    //     f.offset += dz * (f.normal[2] >= 0 ? 1 : -1);
    //   });
    // },
    // // Multiply offset by k for all faces or only listed
    // offsetMul:function (k, list) {
    //   let lf = list.length === 0 ? this.faces : list;
    //   lf.forEach(function (f) {
    //     f.offset *= k;
    //   });
    // },
    // // Divide offset around average offset, to fold between
    // offsetBetween:function (list) {
    //   let average = 0;
    //   let n       = 0;
    //   list.forEach(function (f) {
    //     average += f.offset * (f.normal[2] >= 0 ? 1 : -1);
    //     n++;
    //   });
    //   average /= n;
    //   this.faces.forEach(function (f) {
    //     f.offset -= average * (f.normal[2] >= 0 ? 1 : -1);
    //   });
    //   list.forEach(function (f) {
    //     f.offset /= 2;
    //   });
    // },

    // 2D Boundary [xmin, ymin, xmax, ymax]*/
    get2DBounds:function () {
      let xmax = -100.0, xmin = 100.0;
      let ymax = -100.0, ymin = 100.0;
      this.points.forEach(function (p) {
        let x = p.xf, y = p.yf;
        if (x > xmax) xmax = x;
        if (x < xmin) xmin = x;
        if (y > ymax) ymax = y;
        if (y < ymin) ymin = y;
      });
      return {xmin, ymin, xmax, ymax};
    },
    // Fit the model to -200 +200
    zoomFit:function () {
      let b     = this.get3DBounds();
      let w     = 400;
      let scale = w / Math.max(b[2] - b[0], b[3] - b[1]);
      let cx    = -(b[0] + b[2]) / 2;
      let cy    = -(b[1] + b[3]) / 2;
      this.move(cx, cy, 0, null);
      this.scaleModel(scale);
    },
    // Scale model
    scaleModel:function (scale) {
      this.points.forEach(function (p) {
        p.x *= scale;
        p.y *= scale;
        p.z *= scale;
      });
    },
    // 3D Boundary View [xmin, ymin, xmax, ymax]
    get3DBounds:function () {
      let xmax = -200.0, xmin = 200.0;
      let ymax = -200.0, ymin = 200.0;
      this.points.forEach(function (p) {
        let x = p.x, y = p.y;
        if (x > xmax) xmax = x;
        if (x < xmin) xmin = x;
        if (y > ymax) ymax = y;
        if (y < ymin) ymin = y;
      });
      return [xmin, ymin, xmax, ymax]
    }
  };
  // File: js/Interpolator.js
  // Maps time to time
  // interpolate(tn) returns t for tn.
  // t and tn should start at 0.0 and end at 1.0
  // between 0 and 1, t can be < 0 (anticipate) and >1 (overshoot)
  // use Padé approximations
  var Interpolator = {
    // Linear "il"
    LinearInterpolator:function (t) {
      return t;
    },
    // Starts and ends slowly accelerate between "iad"
    /** @return {number} */
    AccelerateDecelerateInterpolator:function (t) {
      return (Math.cos((t + 1) * Math.PI) / 2.0) + 0.5;
    },
    // Model of a spring with overshoot "iso"
    /** @return {number} */
    SpringOvershootInterpolator:function (t) {
      if (t < 0.1825)
        return (((-237.110 * t) + 61.775) * t + 3.664) * t + 0.000;
      if (t < 0.425)
        return (((74.243 * t) - 72.681) * t + 21.007) * t - 0.579;
      if (t < 0.6875)
        return (((-16.378 * t) + 28.574) * t - 15.913) * t + 3.779;
      if (t < 1.0)
        return (((5.120 * t) - 12.800) * t + 10.468) * t - 1.788;
      return (((-176.823 * t) + 562.753) * t - 594.598) * t + 209.669;
    },
    // Model of a spring with bounce "isb"
    // 1.0-Math.exp(-4.0*t)*Math.cos(2*Math.PI*t)
    /** @return {number} */
    SpringBounceInterpolator:function (t) {
      let x = 0.0;
      if (t < 0.185)
        x = (((-94.565 * t) + 28.123) * t + 2.439) * t + 0.000;
      else if (t < 0.365)
        x = (((-3.215 * t) - 4.890) * t + 5.362) * t + 0.011;
      else if (t < 0.75)
        x = (((5.892 * t) - 10.432) * t + 5.498) * t + 0.257;
      else if (t < 1.0)
        x = (((1.520 * t) - 2.480) * t + 0.835) * t + 1.125;
      else x = (((-299.289 * t) + 945.190) * t - 991.734) * t + 346.834;
      return x > 1 ? 2 - x : x;
    },
    // Model of a gravity with bounce "igb"
    // a = 8.0, k=1.5; x=(a*t*t-v0*t)*Math.exp(-k*t);
    /** @return {number} */
    GravityBounceInterpolator:function (t) {
      let x = 0.0;
      if (t < 0.29)
        x = (((-14.094 * t) + 9.810) * t - 0.142) * t + 0.000;
      else if (t < 0.62)
        x = (((-16.696 * t) + 21.298) * t - 6.390) * t + 0.909;
      else if (t < 0.885)
        x = (((31.973 * t) - 74.528) * t + 56.497) * t + -12.844;
      else if (t < 1.0)
        x = (((-37.807 * t) + 114.745) * t - 114.938) * t + 39.000;
      else x = (((-7278.029 * t) + 22213.034) * t - 22589.244) * t + 7655.239;
      return x > 1 ? 2 - x : x;
    },
    // Bounce at the end "ib"
    /** @return {number} */
    BounceInterpolator:function (t) {
      function bounce(t) {
        return t * t * 8.0;
      }
      t *= 1.1226;
      if (t < 0.3535) return bounce(t);
      else if (t < 0.7408) return bounce(t - 0.54719) + 0.7;
      else if (t < 0.9644) return bounce(t - 0.8526) + 0.9;
      else return bounce(t - 1.0435) + 0.95;
    },
    // Overshoot "io"
    /** @return {number} */
    OvershootInterpolator:function (t) {
      const mTension = 2;
      t -= 1.0;
      return t * t * ((mTension + 1) * t + mTension) + 1.0;
    },
    // Anticipate "ia"
    /** @return {number} */
    AnticipateInterpolator:function (t) {
      const mTension = 0; // 2
      return t * t * ((mTension + 1) * t - mTension);
    },
    // Anticipate Overshoot "iao"
    /** @return {number} */
    AnticipateOvershootInterpolator:function (t) {
      const mTension = 1.5;
      function a(t, s) {
        return t * t * ((s + 1) * t - s);
      }
      function o(t, s) {
        return t * t * ((s + 1) * t + s);
      }
      if (t < 0.5) return 0.5 * a(t * 2.0, mTension);
      else return 0.5 * (o(t * 2.0 - 2.0, mTension) + 2.0);
    }
  };

  // File: js/Command.js
  // Called by orTextArea when orTextArea gets "Enter"
  function Command(model) {
    this.model        = model;
    this.toko         = [];
    this.done         = [];
    this.iTok         = 0;
    // State machine
    this.state        = State.idle;
    // Time interpolated at instant 'p' preceding and at instant 'n' current
    this.tni          = 1;
    this.tpi          = 0;
    this.interpolator = Interpolator.LinearInterpolator;
    // scale, ctx, cy, cz used in ZoomFit
    this.za           = [0, 0, 0, 0];
    // Interpolator used in anim() to map tn (time normalized) to tni (time interpolated)
    this.interpolator = Interpolator.LinearInterpolator;
    // Coefficient to multiply value given in Offset commands
    this.kOffset = 1; // 0.2 for real rendering, can be 10 to debug
    // Debug
    this.debug = false;
  }

  // Static values
  const State = {idle:0, run:1, anim:2, pause:3, undo:4};
  // console.log(Object.keys(State)[1]); // run

  // Class methods
  Command.prototype = {
    constructor:Command,

    // Tokenize, split the String in this.toko Array of String @testOK
    tokenize:function (input) {
      let text  = input.replace(/[\);]/g, ' rparent');
      text      = text.replace(/,/g, ' ');
      text      = text.replace(/\/\/.*$/mg, '');
      this.toko = text.split(/\s+/);
      this.iTok = 0;
      if(this.debug){console.log('tokenize:'+this.toko);}
      return this.toko;
    },

    // Read a File @testOK
    readfile:function (filename) {
      let text = null;
      // If we are in NodeJS fs is required
      if (typeof require !== 'undefined') {
        const fs = require('fs');
        text     = fs.readFileSync(filename, 'utf-8');
      }
      // If we are in browser XHR or Script embedded
      else {
        if (document.getElementById("cocotte")) {
          text = document.getElementById("cocotte").text;
        } else {
          const request = new XMLHttpRequest();
          request.onreadystatechange = function () {
            if (request.readyState === XMLHttpRequest.DONE && request.status === 200) {
              const type = request.getResponseHeader("Content-Type");
              if (type.match(/^text/)) { // Make sure response is text
                text = request.responseText;
              }
            } else if (request.readyState !== XMLHttpRequest.OPENED) {
              console.log("Error ? state:" + request.readyState + " status:" + request.status);
            }
          };
          // XMLHttpRequest.open(method, url, async)
          // Here async = false ! => Warning from Firefox, Chrome,
          request.open('GET', filename, false);
          request.send(null);
        }
      }
      if (text === null) {
        console.log("Error reading:" + filename);
      }
      if(this.debug){console.log("text:"+text);}
      return text;
    },

    // Execute one command token on model
    execute:function () {
      if(this.debug){console.log("Command.execute:"+this.toko[this.iTok]);}
      // Commands
      // "d : define" @testOK
      if (this.toko[this.iTok] === "d" || this.toko[this.iTok] === "define") {
        // Define sheet by N points x,y CCW
        this.iTok++;
        let list = [];
        while (Number.isInteger(Number(this.toko[this.iTok]))) {
          list.push(this.toko[this.iTok++]);
        }
        this.model.init(list);
      }
      // Origami splits
      // "b : by" @testOK
      else if (this.toko[this.iTok] === "b" || this.toko[this.iTok] === "by") {
        // Split by two points
        this.iTok++;
        let a = this.model.points[this.toko[this.iTok++]];
        let b = this.model.points[this.toko[this.iTok++]];
        this.model.splitBy(a, b);
      }
      // "c : cross"  @testOK
      else if (this.toko[this.iTok] === "c" || this.toko[this.iTok] === "cross") {
        // Split across two points all (or just listed) faces
        this.iTok++;
        let a = this.model.points[this.toko[this.iTok++]];
        let b = this.model.points[this.toko[this.iTok++]];
        this.model.splitCross(a, b);
      }
      // "p : perpendicular"  @testOK
      else if (this.toko[this.iTok] === "p" || this.toko[this.iTok] === "perpendicular") {
        // Split perpendicular of line by point
        this.iTok++;
        let s = this.model.segments[this.toko[this.iTok++]];
        let p = this.model.points[this.toko[this.iTok++]];
        this.model.splitOrtho(s, p);
      }
      // "lol : LineOnLine" TODO test
      else if (this.toko[this.iTok] === "lol" || this.toko[this.iTok] === "lineonline") {
        // Split by a plane passing between segments
        this.iTok++;
        let s0 = this.model.segments[this.toko[this.iTok++]];
        let s1 = this.model.segments[this.toko[this.iTok++]];
        this.model.splitLineToLine(s0, s1);
      }
      // Segment split TODO test
      // "s : split seg numerator denominator"
      else if (this.toko[this.iTok] === "s" || this.toko[this.iTok] === "split") {
        // Split set by N/D
        this.iTok++;
        let s = this.model.segments[this.toko[this.iTok++]];
        let n = this.toko[this.iTok++];
        let d = this.toko[this.iTok++];
        this.model.splitSegmentByRatio(s, n / d);
      }

      // Animation commands use tni tpi
      // " r : rotate Seg Angle Points"
      else if (this.toko[this.iTok] === "r" || this.toko[this.iTok] === "rotate") {
        // Rotate Seg Angle Points with animation
        this.iTok++;
        let s     = this.model.segments[this.toko[this.iTok++]];
        let angle = (this.toko[this.iTok++] * (this.tni - this.tpi));
        let list  = this.listPoints();
        this.model.rotate(s, angle, list);
        this.iTok = this.iTok;
      }
      // "f : fold to angle"
      else if (this.toko[this.iTok] === "f" || this.toko[this.iTok] === "fold") {
        this.iTok++;
        let s = this.model.segments[this.toko[this.iTok++]];
        // Cache current angle at start of animation
        if (this.tpi === 0)
          this.angleBefore = this.model.computeAngle(s);
        let angle = ((this.toko[this.iTok++] - this.angleBefore) * (this.tni - this.tpi));
        let list = this.listPoints();
        // Reverse segment to have the first point on left face
        if (this.tpi === 0 && this.model.faceRight(s.p1, s.p2).points.indexOf(list[0]) !== -1)
          s.reverse();
        this.model.rotate(s, angle, list);
      }
      // Adjust all or listed points
      // "a : adjust"
      else if (this.toko[this.iTok] === "a") {
        // Adjust Points in 3D to fit 3D length
        this.iTok++;
        let list  = this.listPoints();
        let liste = list.length === 0 ? this.model.points : list;
        let dmax = this.model.adjustList(liste);
      }
      // // Adjust with only given segments
      // else if (this.toko[this.iTok] === "as") { // "as : adjust set segments"
      //   // Adjust Points in 3D to fit 3D length
      //   this.iTok++;
      //   let p0 = this.model.points.get(this.toko[this.iTok++]);
      //   this.model.adjustSegments(p0, this.model.segments);
      // }
      //
      // else if (this.toko[this.iTok] === "flat") { // "flat : z = 0"
      //   // Move all let to z = 0
      //   this.iTok++;
      //   this.model.flat(this.model.points);
      // }
      // Offsets
      else if (this.toko[this.iTok] === "o") { // "o : offset"
        // Offset by dz the list of faces : o dz f1 f2...
        this.iTok++;
        let dz = this.toko[this.iTok++] * this.kOffset;
        let list  = this.listFaces();
        this.model.offset(dz, list);
      }
      // Moves
      else if (this.toko[this.iTok] === "m") { // "m : move dx dy dz pts"
        // Move 1 let in 3D with Coefficient for animation
        this.iTok++;
        this.model.move(this.toko[this.iTok++] * (this.tni - this.tpi), this.toko[this.iTok++]* (this.tni - this.tpi)
          , this.toko[this.iTok++] * (this.tni - this.tpi)
          , this.model.points);
      }
      else if (this.toko[this.iTok] === "mo") { // "mo : move on"
        // Move all points on one with animation
        this.iTok++;
        let p0 = this.model.points.get(this.toko[this.iTok++]);
        let k2 = ((1 - this.tni) / (1 - this.tpi));
        let k1 = (this.tni - this.tpi * k2);
        this.model.moveOn(p0, k1, k2, this.model.points);
      }
      // Turns
      else if (this.toko[this.iTok] === "tx") { // "tx : TurnX"
        this.iTok++;
        this.model.turn(1, Number(this.toko[this.iTok++]) * (this.tni - this.tpi));
      }
      else if (this.toko[this.iTok] === "ty") { // "ty : TurnY"
        this.iTok++;
        this.model.turn(2, Number(this.toko[this.iTok++]) * (this.tni - this.tpi));
      }
      else if (this.toko[this.iTok] === "tz") { // "tz : TurnZ"
        this.iTok++;
        this.model.turn(3, Number(this.toko[this.iTok++]) * (this.tni - this.tpi));
      }
      // Zooms
      else if (this.toko[this.iTok] === "z") { // "z : Zoom scale,x,y"
        this.iTok++;
        let scale   = this.toko[this.iTok++];
        let x = this.toko[this.iTok++];
        let y = this.toko[this.iTok++];
        // for animation
        let ascale  = ((1 + this.tni * (scale - 1)) / (1 + this.tpi * (scale - 1)));
        let bfactor = (scale * (this.tni / ascale - this.tpi));
        this.model.move(x * bfactor, y * bfactor, 0, null);
        this.model.scaleModel(ascale);
      }
      else if (this.toko[this.iTok] === "zf") { // "zf : Zoom Fit"
        this.iTok++;
        if (this.tpi === 0) {
          let b      = this.model.get3DBounds();
          let w      = 400;
          this.za[0] = w / Math.max(b[2] - b[0], b[3] - b[1]);
          this.za[1] = -(b[0] + b[2]) / 2;
          this.za[2] = -(b[1] + b[3]) / 2;
        }
        let scale   = ((1 + this.tni * (this.za[0] - 1)) / (1 + this.tpi * (this.za[0] - 1)));
        let bfactor = this.za[0] * (this.tni / scale - this.tpi);
        this.model.move(this.za[1] * bfactor, this.za[2] * bfactor, 0, null);
        this.model.scaleModel(scale);
      }
      // Interpolators
      else if (this.toko[this.iTok] === "il") { // "il : Interpolator Linear"
        this.iTok++;
        this.interpolator = Interpolator.LinearInterpolator;
      }
      else if (this.toko[this.iTok] === "ib") { // "ib : Interpolator Bounce"
        this.iTok++;
        this.interpolator = Interpolator.BounceInterpolator;
      } else if (this.toko[this.iTok] === "io") { // "io : Interpolator OverShoot"
        this.iTok++;
        this.interpolator = Interpolator.OvershootInterpolator;
      }
      else if (this.toko[this.iTok] === "ia") { // "ia : Interpolator Anticipate"
        this.iTok++;
        this.interpolator = Interpolator.AnticipateInterpolator;
      }
      else if (this.toko[this.iTok] === "iao") { // "iao : Interpolator Anticipate OverShoot"
        this.iTok++;
        this.interpolator = Interpolator.AnticipateOvershootInterpolator;
      }
      else if (this.toko[this.iTok] === "iad") { // "iad : Interpolator Accelerate Decelerate"
        this.iTok++;
        this.interpolator = Interpolator.AccelerateDecelerateInterpolator;
      }
      else if (this.toko[this.iTok] === "iso") { // "iso Interpolator Spring Overshoot"
        this.iTok++;
        this.interpolator = Interpolator.SpringOvershootInterpolator;
      }
      else if (this.toko[this.iTok] === "isb") { // "isb Interpolator Spring Bounce"
        this.iTok++;
        this.interpolator = Interpolator.SpringBounceInterpolator;
      }
      else if (this.toko[this.iTok] === "igb") { // "igb : Interpolator Gravity Bounce"
        this.iTok++;
        this.interpolator = Interpolator.GravityBounceInterpolator;
      }
      // Mark points and segments
      else if (this.toko[this.iTok] === "pt") { // "select points"
        this.iTok++;
        this.model.selectPts(this.model.points);
      }
      else if (this.toko[this.iTok] === "seg") { // "select segments"
        this.iTok++;
        this.model.selectSegs(this.model.segments);
      }
      else if (this.toko[this.iTok] === "end") { // "end" give Control back to CommandLoop
        this.iTok = this.toko.length;
      }
      // Fall through
      else if (this.toko[this.iTok] === "t"
        || this.toko[this.iTok] === "rparent"
        || this.toko[this.iTok] === "u"
        || this.toko[this.iTok] === "co"
        || this.toko[this.iTok] === "end") {
        console.log("Warn unnecessary token :" + this.toko[this.iTok] + "\n");
        this.iTok++;
        return -1;
      } else {
        //mainPane.orTextArea.print("execute unknown token :" + this.toko[this.iTok] + "\n");
        //mainPane.orTextArea.clean();
        //mainPane.orTextArea.println("Commands : ");
        //mainPane.orTextArea.println("Define    : d x y x y x y x y;");
        //mainPane.orTextArea.println("By        : b p1 p2 [f]     LineOnLine: l p1 p2 p3 [f]");
        //mainPane.orTextArea.println("CrossFace : c p1 p2 [f]     Perpendicular  : p s1 p1 [f]");
        //mainPane.orTextArea.println("Split     : s sn Numerator Denominator ");
        //mainPane.orTextArea.println("Rotate    : r s a [p]       Adjust        : a p p...;");
        //mainPane.orTextArea.println("Fold      : f s a [p]");
        //mainPane.orTextArea.println("Move      : m p x y z;      Offset        : o f dz");
        //mainPane.orTextArea.println("Time t duration ...)        Turn XYZ      : tx ty tz angle");
        //mainPane.orTextArea.println("Zoom      : z ratio x y     Interpolation : il ib ia io iao it ito ig");
        //mainPane.orTextArea.println("Read file.txt   2D  3D  Db  u");
        this.iTok++; // ignore
      }
      this.iTok = this.iTok;
      return this.iTok;
    },

    // Make a list from following points numbers @testOK
    listPoints:function () {
      let list = [];
      while (Number.isInteger(Number(this.toko[this.iTok]))) {
        list.push(this.model.points[this.toko[this.iTok++]]);
      }
      return list;
    },

    // Make a list from following segments numbers @testOK
    listSegments:function () {
      let list = [];
      while (Number.isInteger(Number(this.toko[this.iTok]))) {
        list.push(this.model.segments[this.toko[this.iTok++]]);
      }
      return list;
    },
    // Make a list from following faces numbers @testOK
    listFaces:function () {
      let list = [];
      if(this.debug){console.log("listFaces:"+this.toko[this.iTok]);}
      while (Number.isInteger(Number(this.toko[this.iTok]))) {
        if(this.debug){console.log("listFaces push:"+this.toko[this.iTok]);}
        list.push(this.model.faces[this.toko[this.iTok++]]);
      }
      return list;
    },
    // Main entry Point
    // Execute list of commands
    command:function (cde) {
      // console.log("State:"+Object.keys(State)[1]);
// -- State Idle tokenize list of command
      if (this.state === State.idle) {
        if (cde === "u") {
          this.toko = this.done.slice().reverse();
          this.undo(); // We are exploring this.toko[]
          return;
        }
        else if (cde.startsWith("read")) {
          let filename = cde.substring(5);
          if (filename.indexOf("script") !== -1) {
            // Expect "read script cocotte" => filename="script cocotte" => id="cocotte"
            // With a tag <script id="cocotte" type="not-javascript">d ...< /script> in html file
            let id = filename.substring(7);
            cde    = document.getElementById(id).text;
          } else {
            // Attention replace argument cde by the content of the file
            cde = this.readfile(filename.trim());
          }
          if (cde === null)
            return;
          // On success clear this.toko and use read cde
          this.done = [];
          this.undo = [];
          // Continue to Execute
        }
        else if (cde === "co" || cde === "pa") {
          // In idle, no job, continue, or pause are irrelevant
          return;
        }
        else if (cde.startsWith("d")) {
          // Starts a new folding
          this.done = [];
          this.undo = [];
        }
        // Execute
        this.toko  = this.tokenize(cde);
        this.state = State.run;
        this.iTok  = 0;
        this.commandLoop();
        return;
      }
      // -- State Run execute list of command
      if (this.state === State.run) {
        this.commandLoop();
        return;
      }
      // -- State Animation execute up to ')' or pause
      if (this.state === State.anim) {
        // "Pause"
        if (cde === "pa") {
          this.state = State.pause;
        }
        return;
      }
      // -- State Paused in animation
      if (this.state === State.pause) {
        // "Continue"
        if (cde === "co") {
          // performance.now() vs new Date().getTime();
          this.pauseDuration = new Date().getTime() - this.pauseStart;
          // Continue animation
          //mainPane.view3d.animate(this);
          this.state = State.anim;
        }
        else if (cde === "u") {
          // Undo one step
          this.state = State.undo;
          this.undo();
        }
        return;
      }
      // -- State undo
      if (this.state === State.undo) {
        if (this.undoInProgress === false) {
          if (cde === "u") {
            // Ok continue to undo
            this.undo();
          }
          else if (cde === "co") {
            // Switch back to run
            this.state = State.run;
            this.commandLoop();
          }
          else if (cde === "pa") {
            // Forbidden ignore pause
          } else {
            // A new Command can only come from Debug
            // Removes 't' or 'd'
            this.iTok--;
            // Execute
            this.toko  = this.tokenize(cde);
            this.state = State.run;
            this.iTok  = 0;
            this.commandLoop();
          }
        }
      }
    },

    // Loop to execute commands
    commandLoop:function () {
      if (this.debug) {
        console.log("commandloop:" + this.toko[this.iTok]);
      }
      while (this.iTok < this.toko.length) {
        // Breaks loop to launch animation on 't'
        if (this.toko[this.iTok] === "t") {
          // Time t duration ... )
          this.done.push(this.toko[this.iTok++]);
          // this.iTok will be incremented by duration = this.toko[this.iTok++]
          this.done.push(this.toko[this.iTok]);
          this.duration      = this.toko[this.iTok++];
          this.pauseDuration = 0;
          this.state         = State.anim;
          this.animStart();
          // Return breaks the loop, giving control to anim
          return;
        }
        else if (this.toko[this.iTok] === "rparent") {
          // Finish pushing command
          this.done.push(this.toko[this.iTok++]);
          continue;
        }

        let iBefore = this.iTok;

        if (this.debug) {
          console.log("commandLoop execute:" + this.toko[this.iTok]);
        }
        // Execute one command
        let iReached = this.execute();

        // Push modified model
        this.pushUndo();
        // Add done commands to done list
        while (iBefore < iReached) {
          this.done.push(this.toko[iBefore++]);
        }
        // Post an event to repaint
        // The repaint will not occur till next animation, or end Cde
        this.model.change = true;
      }
      // End of command line switch to idle
      if (this.state === State.run) {
        this.state = State.idle;
      }
    },

    // Sets a flag in model which is tested in Animation loop in Orisim3d.js
    animStart:function () {
      if (this.debug) {
        console.log("Command.animStart");
      }
      this.model.change = true;
      this.tstart       = new Date().getTime();
      this.tpi          = 0.0;
    },

    // Called from Orisim3d.js in Animation loop
    // return true if anim should continue false if anim should end
    anim:function () {
      if (this.debug) {
        console.log("Command.anim state:" + Object.keys(State)[this.state]);
      }
      if (this.state === State.undo) {
        let index = this.popUndo();
        let ret   = (index > this.iTok);
        // Stop undo if undo mark reached and switch to repaint
        if (ret === false) {
          this.undoInProgress = false;
          //mainPane.repaint();
        }
        return ret;
      }
      else if (this.state === State.pause) {
        this.pauseStart = new Date().getTime();
        return false;
      }
      else if (this.state !== State.anim) {
        return false;
      }
      // We are in state anim
      let t  = new Date().getTime();
      // Compute tn varying from 0 to 1
      let tn = (t - this.tstart - this.pauseDuration) / this.duration; // tn from 0 to 1
      if (tn > 1.0)
        tn = 1.0;
      this.tni = this.interpolator(tn);

      // Execute commands just after t xxx up to including ')'
      this.iBeginAnim = this.iTok;
      while (this.toko[this.iTok] !== "rparent") {
        this.execute();
        if (this.iTok === this.toko.length) {
          console.log("Warning missing parent !");
          break;
        }
      }
      // For undoing animation
      this.pushUndo();

      // Keep t (tpi) preceding t now (tni)
      this.tpi = this.tni; // t preceding

      // If Animation is finished, set end values
      if (tn >= 1.0) {
        this.tni = 1.0;
        this.tpi = 0.0;
        // Push done
        while (this.iBeginAnim < this.iTok) {
          // Time t duration ... )
          this.done.push(this.toko[this.iBeginAnim++]);
        }
        // Switch back to run and launch next cde
        this.state = State.run;
        this.commandLoop();
        // If commandLoop has launched another animation we continue
        if (this.state === State.anim)
          return true;
        // OK we stop anim
        return false;
      }
      // Rewind to continue animation
      this.iTok = this.iBeginAnim;
      return true;
    },

    pushUndo:function () {
    },
    popUndo:function () {
    }
  };

  // File: js/View2d
  // View2d Constructor
  function View2d(model, canvas2d) {
    // Instance variables
    this.model           = model;
    this.canvas2d        = canvas2d;
    // Keep ref to this view2d for event
    this.canvas2d.view2d = this;
    if (this.canvas2d === null) {
      return;
    }
    this.ctx     = this.canvas2d.getContext('2d');
    // Values set by fit()
    this.scale   = 1;
    this.xOffset = 0;
    this.yOffset = 0;
    // Resize canvas to fit model
    this.fit();
    // Mouse hit
    this.canvas2d.addEventListener('mousedown', this.mouseDown);
  }

  // Class methods
  View2d.prototype = {
    constructor:View2d,

    // Point under mousedown
    mouseDown:function (ev) {
      // Event clic
      var rect = ev.target.getBoundingClientRect();
      var x    = ev.clientX - rect.left;
      var y    = ev.clientY - rect.top;

      // Model scale and offset from view2d
      let view2d  = ev.target.view2d;
      let scale   = view2d.scale;
      let xOffset = view2d.xOffset;
      let yOffset = view2d.yOffset;

      // Model clic
      let xf = (x - xOffset) / scale;
      let yf = -(y - yOffset) / scale;

      // Debug
      let ctx = view2d.ctx;

      let model = view2d.model;
      model.points.find(function (p) {
        if (Point.compare2d(p, new Point(xf, yf)) < 10) {
          console.log("P :" + model.points.indexOf(p) + ' ' + p.toString());

          // Debug
          let xf        = p.xf * scale + xOffset;
          let yf        = -p.yf * scale + yOffset;
          // Circle
          ctx.fillStyle = 'magenta';
          ctx.beginPath();
          ctx.arc(xf, yf, 12, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.fill();
          // label
          ctx.fillStyle = 'black';
          let i         = model.points.indexOf(p);
          if (i < 10) {
            ctx.fillText(String(i), xf - 4, yf + 5);
          } else {
            ctx.fillText(String(i), xf - 8, yf + 5);
          }
        }
      });
      model.segments.find(function (s) {
        if (Segment.distanceToSegment(s, new Point(xf, yf)) < 10) {
          let xf1 = s.p1.xf * scale + xOffset;
          let yf1 = -s.p1.yf * scale + yOffset;
          let xf2 = s.p2.xf * scale + xOffset;
          let yf2 = -s.p2.yf * scale + yOffset;
          let xc  = (xf1 + xf2) / 2;
          let yc  = (yf1 + yf2) / 2;
          // Segment
          ctx.beginPath();
          ctx.moveTo(xf1, yf1);
          ctx.lineTo(xf2, yf2);
          ctx.closePath();
          ctx.stroke();
          // Circle
          ctx.fillStyle = 'magenta';
          ctx.beginPath();
          ctx.arc(xc, yc, 12, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.fill();
          // label
          let i         = model.segments.indexOf(s);
          ctx.fillStyle = 'black';
          if (i < 10) {
            ctx.fillText(String(i), xc - 4, yc + 5);
          } else {
            ctx.fillText(String(i), xc - 8, yc + 5);
          }
        }
      });
      //model.faces.forEach(function(f, i){
      //  console.log("F"+i+":"+f);
      //})
    },
    // Draw all points in blue
    drawPoint:function () {
      let ctx     = this.ctx;
      let scale   = this.scale;
      let xOffset = this.xOffset;
      let yOffset = this.yOffset;

      let points      = this.model.points;
      ctx.font        = '18px serif';
      ctx.strokeStyle = 'blue';
      points.forEach((p, i) => {
        let xf        = p.xf * scale + xOffset;
        let yf        = -p.yf * scale + yOffset;
        // Circle
        ctx.fillStyle = 'skyblue';
        ctx.beginPath();
        ctx.arc(xf, yf, 12, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fill();
        // label
        ctx.fillStyle = 'black';
        if (i < 10) {
          ctx.fillText(String(i), xf - 4, yf + 5);
        } else {
          ctx.fillText(String(i), xf - 8, yf + 5);
        }
      });
    },
    // Draw all segments in green
    drawSegment:function () {
      let ctx     = this.ctx;
      let scale   = this.scale;
      let xOffset = this.xOffset;
      let yOffset = this.yOffset;

      let segments    = this.model.segments;
      ctx.font        = '18px serif';
      ctx.strokeStyle = 'green';
      segments.forEach((s, i) => {
        let xf1 = s.p1.xf * scale + xOffset;
        let yf1 = -s.p1.yf * scale + yOffset;
        let xf2 = s.p2.xf * scale + xOffset;
        let yf2 = -s.p2.yf * scale + yOffset;
        let xc  = (xf1 + xf2) / 2;
        let yc  = (yf1 + yf2) / 2;
        // Highlight
        if (s.highlight) {
          ctx.strokeStyle = 'red';
        } else {
          ctx.strokeStyle = 'green';
        }
        // Segment
        ctx.beginPath();
        ctx.moveTo(xf1, yf1);
        ctx.lineTo(xf2, yf2);
        ctx.closePath();
        ctx.stroke();
        // Circle
        ctx.fillStyle = 'lightgreen';
        ctx.beginPath();
        ctx.arc(xc, yc, 12, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fill();
        // label
        ctx.fillStyle = 'black';
        if (i < 10) {
          ctx.fillText(String(i), xc - 4, yc + 5);
        } else {
          ctx.fillText(String(i), xc - 8, yc + 5);
        }
      });
    },
    // Draw all faces
    drawFaces:function () {
      let ctx     = this.ctx;
      let scale   = this.scale;
      let xOffset = this.xOffset;
      let yOffset = this.yOffset;

      let faces       = this.model.faces;
      ctx.font        = '18px serif';
      ctx.strokeStyle = 'black';
      faces.forEach((f, i) => {
        let pts = f.points;
        let cx  = 0;
        let cy  = 0;
        ctx.beginPath();
        let xf = pts[0].xf * scale + xOffset;
        let yf = -pts[0].yf * scale + yOffset;
        ctx.moveTo(xf, yf);
        pts.forEach(function (p) {
          xf = p.xf * scale + xOffset;
          yf = -p.yf * scale + yOffset;
          ctx.lineTo(xf, yf);
          cx += xf;
          cy += yf;
        });
        ctx.closePath();
        ctx.fillStyle = 'lightblue';
        ctx.fill();

        // Circle
        cx /= pts.length;
        cy /= pts.length;
        ctx.beginPath();
        ctx.arc(cx, cy, 12, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fillStyle = 'lightcyan';
        ctx.fill();
        // label
        ctx.fillStyle = 'black';
        if (i < 10) {
          ctx.fillText(String(i), cx - 4, cy + 5);
        } else {
          ctx.fillText(String(i), cx - 8, cy + 5);
        }
      });
    },
    // Draw the Model
    draw:function draw() {
      if (this.canvas2d === null) {
        return;
      }
      this.ctx.clearRect(0, 0, this.canvas2d.width, this.canvas2d.height);
      this.drawFaces();
      this.drawSegment();
      this.drawPoint();
    },

    // Fit to show all the model in the view, ie compute scale
    fit:function fit() {
      // Model
      const bounds    = this.model.get2DBounds();
      let modelWidth  = bounds.xmax - bounds.xmin;
      let modelHeight = bounds.ymax - bounds.ymin;

      // <div> containing Canvas
      let viewWidth  = this.canvas2d.clientWidth;
      let viewHeight = this.canvas2d.clientHeight;

      // Resize canvas to fit <div>, should not be necessary but is
      this.canvas2d.width  = viewWidth;
      this.canvas2d.height = viewHeight;

      // Compute Scale to fit
      const scaleX = viewWidth / modelWidth;
      const scaleY = viewHeight / modelHeight;
      this.scale   = Math.min(scaleX, scaleY) / 1.1;

      // Compute Offset to center drawing
      this.xOffset = viewWidth / 2;
      this.yOffset = viewHeight / 2;
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = View2d;
  }
  // Matrix4
  function Matrix4() {
    this.elements = new Float32Array(
      [1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1]);
  }
  Matrix4.prototype = {
    // Copy matrix
    set:function (src) {
      const s = src.elements;
      const d = this.elements;
      if (s === d) {
        return;
      }
      for (let i = 0; i < 16; ++i) {
        d[i] = s[i];
      }
      return this;
    },

    // Multiply this matrix from the right
    multiply:function (other) {
      let i, e, a, b, ai0, ai1, ai2, ai3;
      // Calculate e = a * b
      e = this.elements;
      a = this.elements;
      b = other.elements;
      // If e equals b, copy b to temporary matrix.
      if (e === b) {
        b = new Float32Array(16);
        for (i = 0; i < 16; ++i) {
          b[i] = e[i];
        }
      }
      for (i = 0; i < 4; i++) {
        ai0       = a[i];
        ai1       = a[i + 4];
        ai2       = a[i + 8];
        ai3       = a[i + 12];
        e[i]      = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
        e[i + 4]  = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
        e[i + 8]  = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
        e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
      }
      return this;
    },

    // Multiply this matrix by rotation angle and axe
    rotate:function (angle, x, y, z) {
      return this.multiply(new Matrix4().setRotate(angle, x, y, z));
    },

    // Set this matrix to rotation angle and axe
    setRotate:function (angleDeg, x, y, z) {
      let e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;
      let angle = Math.PI * angleDeg / 180;
      e         = this.elements;
      s         = Math.sin(angle);
      c         = Math.cos(angle);
      if (0 !== x && 0 === y && 0 === z) {
        // Rotation around X axis
        if (x < 0) {
          s = -s;
        }
        e[0]  = 1;
        e[4]  = 0;
        e[8]  = 0;
        e[12] = 0;
        e[1]  = 0;
        e[5]  = c;
        e[9]  = -s;
        e[13] = 0;
        e[2]  = 0;
        e[6]  = s;
        e[10] = c;
        e[14] = 0;
        e[3]  = 0;
        e[7]  = 0;
        e[11] = 0;
        e[15] = 1;
      }
      else if (0 === x && 0 !== y && 0 === z) {
        // Rotation around Y axis
        if (y < 0) {
          s = -s;
        }
        e[0]  = c;
        e[4]  = 0;
        e[8]  = s;
        e[12] = 0;
        e[1]  = 0;
        e[5]  = 1;
        e[9]  = 0;
        e[13] = 0;
        e[2]  = -s;
        e[6]  = 0;
        e[10] = c;
        e[14] = 0;
        e[3]  = 0;
        e[7]  = 0;
        e[11] = 0;
        e[15] = 1;
      }
      else if (0 === x && 0 === y && 0 !== z) {
        // Rotation around Z axis
        if (z < 0) {
          s = -s;
        }
        e[0]  = c;
        e[4]  = -s;
        e[8]  = 0;
        e[12] = 0;
        e[1]  = s;
        e[5]  = c;
        e[9]  = 0;
        e[13] = 0;
        e[2]  = 0;
        e[6]  = 0;
        e[10] = 1;
        e[14] = 0;
        e[3]  = 0;
        e[7]  = 0;
        e[11] = 0;
        e[15] = 1;
      }
      else {
        // Rotation around another axis
        len = Math.sqrt(x * x + y * y + z * z);
        if (len !== 1) {
          rlen = 1 / len;
          x *= rlen;
          y *= rlen;
          z *= rlen;
        }
        nc = 1 - c;
        xy = x * y;
        yz = y * z;
        zx = z * x;
        xs = x * s;
        ys = y * s;
        zs = z * s;

        e[0] = x * x * nc + c;
        e[1] = xy * nc + zs;
        e[2] = zx * nc - ys;
        e[3] = 0;

        e[4] = xy * nc - zs;
        e[5] = y * y * nc + c;
        e[6] = yz * nc + xs;
        e[7] = 0;

        e[8]  = zx * nc + ys;
        e[9]  = yz * nc - xs;
        e[10] = z * z * nc + c;
        e[11] = 0;

        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
      }
      return this;
    },

    // Set this matrix to translation by x,y,z
    translate:function (x, y, z) {
      let e = this.elements;
      e[12] += e[0] * x + e[4] * y + e[8] * z;
      e[13] += e[1] * x + e[5] * y + e[9] * z;
      e[14] += e[2] * x + e[6] * y + e[10] * z;
      e[15] += e[3] * x + e[7] * y + e[11] * z;
      return this;
    },
    scale:function (x, y, z) {
      var e = this.elements;
      e[0] *= x;
      e[4] *= y;
      e[8] *= z;
      e[1] *= x;
      e[5] *= y;
      e[9] *= z;
      e[2] *= x;
      e[6] *= y;
      e[10] *= z;
      e[3] *= x;
      e[7] *= y;
      e[11] *= z;
      return this;
    },

    // Multiply the viewing matrix to look at
    lookAt:function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
      return this.multiply(new Matrix4().setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));
    },

    // Set this viewing matrix to look at
    setLookAt:function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
      let e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
      fx   = centerX - eyeX;
      fy   = centerY - eyeY;
      fz   = centerZ - eyeZ;
      // Normalize f.
      rlf  = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);
      fx *= rlf;
      fy *= rlf;
      fz *= rlf;
      // Calculate cross product of f and up.
      sx   = fy * upZ - fz * upY;
      sy   = fz * upX - fx * upZ;
      sz   = fx * upY - fy * upX;
      // Normalize s.
      rls  = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);
      sx *= rls;
      sy *= rls;
      sz *= rls;
      // Calculate cross product of s and f.
      ux   = sy * fz - sz * fy;
      uy   = sz * fx - sx * fz;
      uz   = sx * fy - sy * fx;
      // Set to this.
      e    = this.elements;
      e[0] = sx;
      e[1] = ux;
      e[2] = -fx;
      e[3] = 0;

      e[4] = sy;
      e[5] = uy;
      e[6] = -fy;
      e[7] = 0;

      e[8]  = sz;
      e[9]  = uz;
      e[10] = -fz;
      e[11] = 0;

      e[12] = 0;
      e[13] = 0;
      e[14] = 0;
      e[15] = 1;

      // Translate.
      return this.translate(-eyeX, -eyeY, -eyeZ);
    },

    // Set this as perspective projection matrix by fovy and aspect
    setPerspective:function (fovy, aspect, near, far) {
      let e, rd, s, ct;
      if (near === far || aspect === 0) {
        throw 'null frustum';
      }
      if (near <= 0) {
        throw 'near <= 0';
      }
      if (far <= 0) {
        throw 'far <= 0';
      }
      fovy = Math.PI * fovy / 180 / 2;
      s    = Math.sin(fovy);
      if (s === 0) {
        throw 'null frustum';
      }
      rd   = 1 / (far - near);
      ct   = Math.cos(fovy) / s;
      e    = this.elements;
      e[0] = ct / aspect;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;

      e[4] = 0;
      e[5] = ct;
      e[6] = 0;
      e[7] = 0;

      e[8]  = 0;
      e[9]  = 0;
      e[10] = -(far + near) * rd;
      e[11] = -1;

      e[12] = 0;
      e[13] = 0;
      e[14] = -2 * near * far * rd;
      e[15] = 0;

      return this;
    },

    // Transform vector 3
    transformVector:function (v) {
      let dst = new Float32Array(4);
      for (let i = 0; i < 4; i++) {
        dst[i] = 0.0;
        for (let j = 0; j < 4; j++) {
          dst[i] += v[j] * this.elements[j * 4 + i];
        }
      }
      return dst;
    }
  };

  // File: js/View3d
  // View3d Constructor
  function View3d(model, canvas3d, canvas3dtext) {
    // Instance variables
    this.model        = model;
    this.canvas3d     = canvas3d;
    this.canvas3dtext = canvas3dtext;
    this.gl           = this.canvas3d.getContext('webgl');

    // Initialisation
    this.initWebGL();

    // Textures dimensions
    this.wTexFront = 0; //640/2; // 640x905 ou 400x566 ou 256x256
    this.hTexFront = 0; // 905/2;
    this.wTexBack  = 0; //640/2; // Bizarre 256 normalement
    this.hTexBack  = 0; //905/2;
  }
  // Face Vertex
  View3d.FaceVertexShaderSrc   =
    'attribute vec4 a_Position;\n' +
    'attribute vec2 a_TexCoordFront;\n' +
    'attribute vec2 a_TexCoordBack;\n' +
    'uniform mat4 u_MvMatrix;\n' +
    'varying vec2 v_TexCoordFront;\n' +
    'varying vec2 v_TexCoordBack;\n' +
    'void main() {\n' +
    '  gl_Position = u_MvMatrix * a_Position;\n' +
    '  v_TexCoordFront = a_TexCoordFront;\n' +
    '  v_TexCoordBack = a_TexCoordBack;\n' +
    '}\n';
  // Face Fragment
  View3d.FaceFragmentShaderSrc =
    '#ifdef GL_ES\n' +
    'precision mediump float;\n' +
    '#endif\n' +
    'uniform sampler2D u_SamplerFront;\n' +
    'uniform sampler2D u_SamplerBack;\n' +
    'varying vec2 v_TexCoordFront;\n' +
    'varying vec2 v_TexCoordBack;\n' +
    'void main() {\n' +
    'if (gl_FrontFacing){ \n' +
    '  gl_FragColor = texture2D(u_SamplerFront, v_TexCoordFront);}\n' +
    'else { \n' +
    '  gl_FragColor = texture2D(u_SamplerBack, v_TexCoordBack); }\n' +
    '}\n';

  // Static methods and variables
  // Texture image load callback
  View3d.loadTexture = function (gl, texture, u_Sampler, image) {
    // Flip the image Y coordinate
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // One of the dimensions is not a power of 2, so set the filtering to render it.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
  };

  // Current rotation angle ([x-axis, y-axis] degrees)
  View3d.currentAngle = [0.0, 0.0];
  View3d.scale        = 1.0;

  // Model view projection matrix for Perspective and Current
  View3d.g_MvpMatrix       = new Matrix4();
  View3d.g_MvCurrentMatrix = new Matrix4();

  // Class methods
  View3d.prototype = {
    constructor:View3d,

    // Intialization
    initWebGL:function () {
      this.initShaders();
      this.initTextures();
      this.initPerspective();
      this.initMouseListeners();
      // this.initBuffers();
    },
    // Shaders
    initShaders:function () {
      const gl = this.gl;
      // Face Shader Program
      // Face Vertex
      const vxShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vxShader, View3d.FaceVertexShaderSrc);
      gl.compileShader(vxShader);
      if (!gl.getShaderParameter(vxShader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shader: " + gl.getShaderInfoLog(vxShader));
      }
      // Face Fragment
      const fgShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fgShader, View3d.FaceFragmentShaderSrc);
      gl.compileShader(fgShader);
      if (!gl.getShaderParameter(fgShader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shader: " + gl.getShaderInfoLog(fgShader));
      }
      // Face Shader Program
      const faceShaderProgram = gl.createProgram();
      gl.attachShader(faceShaderProgram, vxShader);
      gl.attachShader(faceShaderProgram, fgShader);
      gl.linkProgram(faceShaderProgram);
      // Use it
      gl.useProgram(faceShaderProgram);
      gl.faceShaderProgram       = faceShaderProgram;
      // Attributes
      const a_vertexPosAttribute = gl.getAttribLocation(faceShaderProgram, "a_Position");
      gl.enableVertexAttribArray(a_vertexPosAttribute);
      const textureCoordAttrFront = gl.getAttribLocation(faceShaderProgram, "a_TexCoordFront");
      gl.enableVertexAttribArray(textureCoordAttrFront);
      const textureCoordAttrBack = gl.getAttribLocation(faceShaderProgram, "a_TexCoordBack");
      gl.enableVertexAttribArray(textureCoordAttrBack);
    },
    // Buffers
    initBuffers:function () {
      const gl  = this.gl;
      // Faces
      let vtx   = []; // vertex
      let ftx   = []; // front texture coords
      let btx   = []; // back texture coords
      let fnr   = []; // front normals coords
      let bnr   = []; // back normals coords
      let fin   = []; // front indices
      let bin   = []; // back indices
      let index = 0;

      for (let iFace = 0; iFace < this.model.faces.length; iFace++) {
        let f   = this.model.faces[iFace];
        let pts = f.points;
        // Normal needed for Offset
        f.computeFaceNormal();
        let n = f.normal;
        // Triangle FAN can be used only because of convex CCW face
        let c = pts[0]; // center
        let p = pts[1]; // previous
        for (let i = 2; i < pts.length; i++) {
          let s = f.points[i]; // second
          vtx.push(c.x + f.offset * n[0]);
          vtx.push(c.y + f.offset * n[1]);
          vtx.push(c.z + f.offset * n[2]);
          fnr.push(n[0]);
          fnr.push(n[1]);
          fnr.push(n[2]);
          bnr.push(-n[0]);
          bnr.push(-n[1]);
          bnr.push(-n[2]);
          // textures
          ftx.push((200 + c.xf) / this.wTexFront);
          ftx.push((200 + c.yf) / this.hTexFront);
          btx.push((200 + c.xf) / this.wTexBack);
          btx.push((200 + c.yf) / this.hTexBack);
          // index
          fin.push(index);
          bin.push(index);
          index++;
          vtx.push(p.x + f.offset * n[0]);
          vtx.push(p.y + f.offset * n[1]);
          vtx.push(p.z + f.offset * n[2]);
          fnr.push(n[0]);
          fnr.push(n[1]);
          fnr.push(n[2]);
          bnr.push(-n[0]);
          bnr.push(-n[1]);
          bnr.push(-n[2]);
          // textures
          ftx.push((200 + p.xf) / this.wTexFront);
          ftx.push((200 + p.yf) / this.hTexFront);
          btx.push((200 + p.xf) / this.wTexBack);
          btx.push((200 + p.yf) / this.hTexBack);
          // index Note +1 for back face index
          fin.push(index);
          bin.push(index + 1);
          index++;
          vtx.push(s.x + f.offset * n[0]);
          vtx.push(s.y + f.offset * n[1]);
          vtx.push(s.z + f.offset * n[2]);
          fnr.push(n[0]);
          fnr.push(n[1]);
          fnr.push(n[2]);
          bnr.push(-n[0]);
          bnr.push(-n[1]);
          bnr.push(-n[2]);
          // textures
          ftx.push((200 + s.xf) / this.wTexFront);
          ftx.push((200 + s.yf) / this.hTexFront);
          btx.push((200 + s.xf) / this.wTexBack);
          btx.push((200 + s.yf) / this.hTexBack);
          // index Note -1 for back face index
          fin.push(index);
          bin.push(index - 1);
          index++;
          // next triangle
          p = s;
        }
      }

      // Face Buffers
      let vertices       = new Float32Array(vtx);
      let texCoordsFront = new Float32Array(ftx);
      let texCoordsBack  = new Float32Array(btx);
      this.initArrayBuffer(gl, gl.faceShaderProgram, vertices, 3, gl.FLOAT, 'a_Position');
      this.initArrayBuffer(gl, gl.faceShaderProgram, texCoordsFront, 2, gl.FLOAT, 'a_TexCoordFront');
      this.initArrayBuffer(gl, gl.faceShaderProgram, texCoordsBack, 2, gl.FLOAT, 'a_TexCoordBack');
      // Indices buffer
      let faceVertexIndicesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceVertexIndicesBuffer);
      let faceVertexIndicesArray = new Uint8Array(fin);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faceVertexIndicesArray, gl.STATIC_DRAW);

      // Used in draw()
      this.nbFacesVertice = faceVertexIndicesArray.length;
    },

    // Create Buffer Arrays and assign to attribute
    initArrayBuffer:function (gl, program, data, num, type, attribute) {
      let buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
      let a_attribute = gl.getAttribLocation(program, attribute);
      gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0);
      gl.enableVertexAttribArray(a_attribute);
    },

    // Textures
    initTextures:function () {
      const gl = this.gl;

      // Create a texture object Front
      let textureFront = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, textureFront);
      // Placeholder One Pixel Color Blue A5CAFF 70ACF3 145, 199, 255
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0x70, 0xAC, 0xF3, 255]));
      let image_front = new Image();
      let that  = this;
      image_front.onload = function(){
        gl.useProgram(gl.faceShaderProgram);
        let u_SamplerFront = gl.getUniformLocation(gl.faceShaderProgram, 'u_SamplerFront');
        gl.uniform1i(u_SamplerFront, 0);
        gl.activeTexture(gl.TEXTURE0);
        View3d.loadTexture(gl, textureFront, u_SamplerFront, image_front, 0 );
        // Textures dimensions
        that.wTexFront = 400; //image_front.width;
        that.hTexFront = 400; //image_front.height;
      };
      // Require CORS
      // image_front.src = './textures/front.jpg';
      image_front.src = window.document.getElementById("front").src;

      // Create a texture object Back
      let textureBack = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, textureBack);
      // Placeholder One Pixel Color Yellow FFFF7A F3EE1B 255, 249, 145
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0xF3, 0xEE, 0x145, 255]));
      let image_back = new Image();
      image_back.onload = function(){
        gl.useProgram(gl.faceShaderProgram);
        let u_SamplerBack = gl.getUniformLocation(gl.faceShaderProgram, 'u_SamplerBack');
        gl.uniform1i(u_SamplerBack, 1);
        gl.activeTexture(gl.TEXTURE1);
        View3d.loadTexture(gl, textureBack, u_SamplerBack, image_back, 1 );
        // Textures dimensions
        // console.log("back w:"+image_back.width+" h:"+image_back.height);
        that.wTexBack = 400; //image_back.width;
        that.hTexBack = 400; //image_back.height;
      };
      // image_back.src = './textures/PinUpYellow.jpg
      image_back.src = window.document.getElementById("back").src;
    },

    // Perspective and background
    initPerspective:function () {
      const gl = this.gl;
      // Set the clear color and enable the depth test
      gl.clearColor(0xAB/255.0, 0xD1/255.0, 0xFF/255.0, 0xFF/255.0);  // Clear to light blue, fully opaque
      gl.clearDepth(1.0);                 // Clear everything
      gl.enable(gl.DEPTH_TEST);           // Enable depth testing
      gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

      // Set view projection matrix
      this.resizeCanvasToDisplaySize(this.canvas3d);//, window.devicePixelRatio);
      gl.viewport(0, 0, this.canvas3d.width, this.canvas3d.height);
      gl.viewport(0, 0, this.canvas3d.width, this.canvas3d.height);

      let viewProjMatrix = new Matrix4();
      viewProjMatrix.setPerspective(50.0, this.canvas3d.width / this.canvas3d.height, 1.0, 10000.0);

      // From EyeX, EyeY, EyeZ to 0,0,0 Up 0,1,0
      viewProjMatrix.lookAt(0, 0, 500, 0, 0, 0, 0, 1, 0);
      View3d.g_MvpMatrix.set(viewProjMatrix);
    },

    // Resize canvas with client dimensions
    resizeCanvasToDisplaySize:function (canvas, multiplier) {
      multiplier   = multiplier || 1;
      const width  = canvas.clientWidth * multiplier | 0;
      const height = canvas.clientHeight * multiplier | 0;
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width  = width;
        canvas.height = height;
        return true;
      }
      return false;
    },

    // Mouse Handler
    initMouseListeners:function () {
      // Last position of the mouse
      View3d.lastX = -1;
      View3d.lastY = -1;
      this.canvas3dtext.addEventListener("mousedown", this.mousedown);
      this.canvas3dtext.addEventListener("mouseup", this.mouseup);
      this.canvas3dtext.addEventListener("mousemove", this.mousemove);
      this.canvas3dtext.addEventListener("dblclick", this.dblclick);
    },
    // Mouse pressed
    mousedown:function (ev) {
      const x    = ev.clientX;
      const y    = ev.clientY;
      // Start dragging
      const rect = ev.target.getBoundingClientRect();
      if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {
        View3d.lastX    = x;
        View3d.lastY    = y;
        View3d.dragging = true;
      }
    },
    // Mouse released
    mouseup:function () {
      View3d.dragging = false;
    },
    // Mouse move
    mousemove:function (ev) {
      const x = ev.clientX;
      const y = ev.clientY;
      if (View3d.dragging) {
        if (ev.shiftKey || ev.altKey) {
          // Zoom
          View3d.scale -= (y - View3d.lastY) / 300;
        } else {
          // Rotation
          const factor           = 300 / ev.target.height;
          const dx               = factor * (x - View3d.lastX);
          const dy               = factor * (y - View3d.lastY);
          // Limit x-axis rotation angle to -90 to 90 degrees
          View3d.currentAngle[0] = View3d.currentAngle[0] + dy;
          View3d.currentAngle[1] = View3d.currentAngle[1] + dx;
        }
      }
      View3d.lastX = x;
      View3d.lastY = y;
    },
    // Mouse double click
    dblclick:function () {
      View3d.currentAngle[0] = 0;
      View3d.currentAngle[1] = 0;
      View3d.scale           = 1.0;
    },

    // Draw
    draw:function () {
      const gl = this.gl;
      this.resizeCanvasToDisplaySize(this.canvas3d);//, window.devicePixelRatio);

      // Faces with texture shader
      gl.useProgram(gl.faceShaderProgram);

      // Static ModelViewProjection Matrix
      View3d.g_MvCurrentMatrix.set(View3d.g_MvpMatrix);
      View3d.g_MvCurrentMatrix.rotate(View3d.currentAngle[0], 1.0, 0.0, 0.0);
      View3d.g_MvCurrentMatrix.rotate(View3d.currentAngle[1], 0.0, 1.0, 0.0);
      View3d.g_MvCurrentMatrix.scale(View3d.scale, View3d.scale, View3d.scale);
      let u_MvMatrix = gl.getUniformLocation(gl.faceShaderProgram, 'u_MvMatrix');
      gl.uniformMatrix4fv(u_MvMatrix, false, View3d.g_MvCurrentMatrix.elements);

      // Clear and draw triangles
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      // Front face
      gl.activeTexture(gl.TEXTURE0);
      gl.cullFace(gl.BACK);
      gl.drawElements(gl.TRIANGLES, this.nbFacesVertice, gl.UNSIGNED_BYTE, 0);
      // Back face
      gl.activeTexture(gl.TEXTURE1);
      gl.cullFace(gl.FRONT);
      gl.drawElements(gl.TRIANGLES, this.nbFacesVertice, gl.UNSIGNED_BYTE, 0);

      // text canvas overlapping
      let ctx      = this.canvas3dtext.getContext("2d");
      const width  = this.canvas3d.clientWidth;
      const height = this.canvas3d.clientHeight; // 700 x 300
      if (this.canvas3dtext.width !== width || this.canvas3dtext.height !== height) {
        this.canvas3dtext.width  = width;
        this.canvas3dtext.height = height;
      }
    }
  };

  // File: js/CommandArea
  // CommandArea constructor
  function CommandArea(command, textArea) {
    // Add Key press EventListener
    textArea.addEventListener('keypress', CommandArea.keypress);
    // Static variables
    CommandArea.textArea = textArea;
    CommandArea.cde      = command;
  }

  // Static methods
  // Key Press listener
  CommandArea.keypress = function (e) {
    let el             = e.target; // HTMLTextAreaElement
    let val            = e.key ? e.key : String.fromCharCode(Number(e.charCode));
    val                = e.keyCode === 13 ? 'Enter' : val;
    e.target.scrollTop = e.target.scrollHeight;
    if (val === 'Enter') {
      let caretPos = el.selectionStart;
      let value    = el.value;
      let start    = value.lastIndexOf('\n', caretPos - 1) + 1;
      let end      = value.indexOf('\n', caretPos);
      if (end === -1) {
        el.value += '\n';
        end = value.length;
      }
      let line = value.substring(start, end);
      // Do not let TextArea handle Enter
      e.preventDefault();
      // Recall only if not on last line
      if (end !== value.length) {
        el.value += line + '\n';
      }
      // Execute
      CommandArea.cde.command(line);
    }
  };

  // Class methods
  CommandArea.prototype = {
    constructor:CommandArea
  };

  // Main Entry Point : Orisim3D
  // Main startup
  if (typeof window !== 'undefined') {
    window.onload = function () {
      // Create model, Command, then lookup view2d, view3d, textarea
      let model = new Model();
      model.init([-200, -200, 200, -200, 200, 200, -200, 200]);
      let command      = new Command(model);
      let canvas2d     = window.document.getElementById('canvas2d');
      let view2d       = canvas2d ? new View2d(model, canvas2d) : null;
      let canvas3d     = window.document.getElementById('canvas3d');
      let canvas3dtext = window.document.getElementById('canvas3dtext');
      let view3d       = canvas3d ? new View3d(model, canvas3d, canvas3dtext) : null;
      let commandarea  = window.document.getElementById('commandarea');
      let textArea     = commandarea ? new CommandArea(command, commandarea) : null;

      // Bind all in OriSim3d
      new Orisim3d(model, view2d, view3d);

      let first = true;

      // Animation loop
      function loop() {
        if (first) {
          // Read Cocotte Script
          // command.command("read script cocotte");
          command.command("read models/cocotte.txt");
          first = false;
        }
        if (model.change) {
          if (view2d !== null) {
            view2d.draw();
          }
          if (view3d !== null) {
            view3d.initBuffers();
          }
          model.change = !!command.anim()
        }
        // Always redraw view3d ?
        view3d.draw();
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    }
  }

  // Main Module
  function Orisim3d(model, view2d, view3d) {
    // Instance variables
    this.model  = model;
    this.view2d = view2d;
    this.view3d = view3d;
  }

  // Class methods
  Orisim3d.prototype = {
    constructor:Orisim3d
  };
</script>

</html>