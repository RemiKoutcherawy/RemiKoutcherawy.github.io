<html lang="fr">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link>
  <meta charset="UTF-8"/>
  <title>vue3Local.html</title>
  <style>
    body { display:block; margin:5px;}
    .height100 { position:relative; width:100%; height:100%;}
    #canvas3d { position:absolute; width:100%; height:100%; left:0; top:0; border:1px solid darkblue; z-index:0;}
    #canvas3dtext { position:absolute; width:100%; height:100%; left:0; top:0; z-index:10; }
    #menu {position:fixed; top:15px; right:15px; background-color:#FFF; z-index:20}
    .menu {position:fixed; top:15px; right:15px; background-color:#ABD1FF; opacity:1; z-index:20}
    .item {display:none;}
  </style>
</head>
<body>
  <div class="height100">
    <canvas id="canvas3d"></canvas>
    <canvas id="canvas3dtext"></canvas>
    <div class="menu">Menu
      <div class="item">cocotte.txt</div>
    </div>
  </div>


  <!-- Inlined models -->
  <script id="cocotte.txt" type="not-javascript">
  // Cocotte
  d -200 200 -200 -200 200 -200 200 200
  // Marque les médianes et diagonales
  c 0 1 c 0 3 c 0 2 c 1 3
  // Marque les demi-bords
  c 0 8 c 8 3 c 0 4 c 4 1
  // Marque les coins
  c 6 0 c 6 1 c 6 2 c 6 3
  // Retourne iad interpolateur accelerate decelerate
  iad
  t 500 ty 180)
  // Replie le coin et retourne
  t 1000 r 48 180 21 0 10)
  o 1 24 0 7 25
  t 500 ty 180)
  // Bord haut
  t 1000 r 35 179 8 17 3) // Pas mal
  t 500 r 55 90 17 3 a 3 19)
  // Côté droit
  t 1000 r 29 179 5 22 2 a 19 3 17)
  t 500 r 54 -45 19 3 17)
  t 100 r 55 -30 17 a 3) // Ferme la patte
  // Oreille bas
  t 500 r 53 -90 22 2 a 2 18) // Bof à revoir
  t 1000 r 45 179 1 12 7 a 18 2 22)
  t 500 r 53 -87 22 2 18 a 18 2)
  t 100 r 52 30 18 a 2) // Ferme la patte
  // Oreille bas gauche
  t 500 r 50 -90 1 12 a 1 24)
  t 1000 r 23 179 4 a 24 1 12)
  t 500 r 50 -87 12 1 24 a 24 1)
  t 100 r 50 -30 24 a 1) // Ferme la patte
  // Replie en ouvrant le bec
  t 500 r 16 -90 10 8 20 17 16 14 3 19 r 40 -90 0)
  t 500 r 16 -80 10 8 20 17 16 14 3 19 a 0)
  // Ajuste à peu près
  r 24 10 4 r 37 -10 8
  r 29 -5 5 8 r 23 -5 7 4
  // Montre
  iao t 1000 zf) t 1000 tz -45) t 1000 zf)
  iso t 4000 ty 360)
  </script>

  <!-- Inlined textures -->
  <img style="display:none;" id="front" src="textures/front.jpg"/>
  <img style="display:none;" id="back"  src="textures/back.jpg"/>


</body>

<!-- Inlined Javascript copy/paste from JS files-->
<script id="Point.js" type="application/javascript">
  // File:src/Point.js
  // Point to hold Points
  // 3D : x y z
  // Flat crease pattern : xf, yf
  function Point(xf, yf, x, y, z) {

    // Create new Point(x,y,z)
    if (arguments.length === 3) {
      // x y z 3D
      this.x  = xf;
      this.y  = yf;
      this.z  = x;
      // x y Flat, in unfolded state
      this.xf = xf;
      this.yf = yf;
      return this;
    }
    // Create new Point(xf,yf)
    else if (arguments.length === 2) {
      // x y Flat, in unfolded state
      this.xf = xf;
      this.yf = yf;
      // x y z 3D
      this.x  = xf;
      this.y  = yf;
      this.z  = 0;
      return this;
    }
    // Create with new Point(xf,yf, x,y,z)
    else {
      // x y Flat, in unfolded state
      this.xf = 0 | xf;
      this.yf = 0 | yf;
      // x y z 3D
      this.x  = 0 | x;
      this.y  = 0 | y;
      this.z  = 0 | z;
    }
    return this;
  }
  // Class methods
  Point.prototype = {
    constructor:Point,
    // Set x y Flat and  x y z 3D
    set5d:function (xf, yf, x, y, z) {
      // x y Flat, in unfolded state
      this.xf = 0 | xf;
      this.yf = 0 | yf;
      // x y z 3D
      this.x  = 0 | x;
      this.y  = 0 | y;
      this.z  = 0 | z;
    },
    // Set x y z 3D
    set3d:function (x, y, z) {
      this.x = 0 | x;
      this.y = 0 | y;
      this.z = 0 | z;
    },
    // Set x y z 2D
    set2d:function (xf, yf) {
      this.xf = 0 | xf;
      this.yf = 0 | yf;
    },
    // Sqrt(this.this)
    length:function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    // Scale
    scale:function (t) {
      this.x *= t;
      this.y *= t;
      this.z *= t;
      return this;
    },
    // Normalize as a vector
    norm:function () {
      var lg = this.length();
      return this.scale(1.0 / lg);
    },

    // String representation
    toString:function () {
      return "[" + Math.round(this.x) + "," + Math.round(this.y) + "," + Math.round(this.z)
        + "  " + Math.round(this.xf) + "," + Math.round(this.yf) + "]";
    },
    // Short String representation
    toXYZString:function () {
      return "[" + Math.round(this.x) + "," + Math.round(this.y) + "," + Math.round(this.z) + "]";
    },
    // Short String representation
    toXYString:function () {
      return "[" + Math.round(this.xf) + "," + Math.round(this.yf) + "]";
    }
  };
  // Static methods
  // Dot a with b
  Point.dot = function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
  };
  // New Vector a + b
  Point.add = function add(a, b) {
    return new Point(a.x + b.x, a.y + b.y, a.z + b.z);
  };
  // New Vector a - b
  Point.sub = function sub(a, b) {
    return new Point(a.x - b.x, a.y - b.y, a.z - b.z);
  };
  // Return 0 if Point is near x,y,z
  Point.compare3d = function compare3D(p1, p2, y, z) {
    if (arguments.length === 2) {
      // compare3D (p1, p2)
      var pdx2 = (p1.x - p2.x) * (p1.x - p2.x);
      var pdy2 = (p1.y - p2.y) * (p1.y - p2.y);
      var pdz2 = (p1.z - p2.z) * (p1.z - p2.z);
      var pd   = pdx2 + pdy2 + pdz2;
      return pd > 1 ? pd : 0;
    } else {
      // compare3D (p1, x,y,z)
      var dx2 = (p1.x - p2) * (p1.x - p2);
      var dy2 = (p1.y - y) * (p1.y - y);
      var dz2 = (p1.z - z) * (p1.z - z);
      var d   = dx2 + dy2 + dz2;
      return d > 1 ? d : 0;
    }
  };
  // Return 0 if Point is near xf,yf
  Point.compare2d = function compare2D(p1, p2) {
    var dx2 = (p1.xf - p2.xf) * (p1.xf - p2.xf);
    var dy2 = (p1.yf - p2.yf) * (p1.yf - p2.yf);
    return Math.sqrt(dx2 + dy2);
  };
  // For Node
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Point;
  }
</script>
<script id="Plane.js" type="application/javascript">
  // File: js/Plane.js
  // Dependencies : import them before Plane.js in browser
  if (typeof module !== 'undefined' && module.exports) {
    var Point = require("./Point.js");
  }

  // Plane is defined by an origin point R and a normal vector N
  // a point P is on plane iff RP.N = 0
  function Plane(r, n) {
    this.r = r;
    this.n = n;
  }

  // Static values
  Plane.THICKNESS = 1;

  // Static methods
  // Define a plane across 2 points
  Plane.across = function (p1, p2) {
    var middle = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);
    var normal = new Point(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
    return new Plane(middle, normal);
  };
  // Plane by 2 points along Z
  Plane.by     = function (p1, p2) {
    var r = new Point(p1.x, p1.y, p1.z);
    // Cross product P2P1 x 0Z
    var n = new Point(p2.y - p1.y, -(p2.x - p1.x), 0);
    return new Plane(r, n);
  };
  // Plane orthogonal to Segment and passing by Point
  Plane.ortho  = function (s, p) {
    var r      = new Point(p.x, p.y, p.z);
    var normal = new Point(s.p2.x - s.p1.x, s.p2.y - s.p1.y, s.p2.z - s.p1.z);
    return new Plane(r, normal);
  };

  // Class methods
  Plane.prototype = {
    isOnPlane:function (p) {
      // Point P is on plane iff RP.N = 0
      var rp = Point.sub(p, this.r);
      var d  = Point.dot(rp, this.n);
      return (Math.abs(d) < 0.1);
    },
    // Intersection of This plane with segment defined by two points
    intersectPoint:function (a, b) {
      // (A+tAB).N = d <=> t = (d-A.N)/(AB.N) then Q=A+tAB 0<t<1
      var ab  = new Point(b.x - a.x, b.y - a.y, b.z - a.z);
      var abn = Point.dot(ab, this.n);
      // segment parallel to plane
      if (abn === 0)
        return null;
      // segment crossing
      var t = (Point.dot(this.r, this.n) - Point.dot(a, this.n)) / abn;
      if (t >= 0 && t <= 1.0)
        return Point.add(a, ab.scale(t));
      return null;
    },
    // Intersection of This plane with Segment Return Point or null
    intersectSeg:function (s) {
      // (A+tAB).N=d <=> t=(d-A.N)/(AB.N) then Q=A+tAB 0<t<1
      var ab  = new Point(s.p2.x - s.p1.x, s.p2.y - s.p1.y, s.p2.z - s.p1.z);
      var abn = Point.dot(ab, this.n);
      if (abn === 0)
        return null;
      var t = (Point.dot(this.r, this.n) - Point.dot(s.p1, this.n)) / abn;
      if (t >= 0 && t <= 1.0)
        return Point.add(s.p1, ab.scale(t));
      return null;
    },
    // Classify point to thick plane 1 in front 0 on -1 behind
    classifyPointToPlane:function (p) {
      // (A+tAB).N = d <=> d<e front, d>e behind, else on plane
      var dist = Point.dot(this.r, this.n) - Point.dot(this.n, p);
      if (dist > Plane.THICKNESS)
        return 1;
      if (dist < -Plane.THICKNESS)
        return -1;
      return 0;
    },
    // toString
    toString:function () {
      return "Pl[r:" + this.r + " n:" + this.n + "]";
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Plane;
  }
</script>
<script id="Segment.js" type="application/javascript">
  // File: js/Segment.js
  // Dependencies : import them before Segment.js in browser
  if (typeof module !== 'undefined' && module.exports) {
    var Point = require('./Point.js');
  }

  // Segment to hold Segments : Two points p1 p2
  function Segment (p1, p2, type) {
    this.p1        = p1;
    this.p2        = p2;
    this.type      = Segment.PLAIN | type;
    this.lg2d = this.length2d();
    this.lg3d = this.length3d();
    this.angle     = 0;
    this.highlight = false;
  }
  // Static values
  Segment.PLAIN     = 0;
  Segment.EDGE      = 1;
  Segment.MOUNTAIN  = 2;
  Segment.VALLEY    = 3;
  Segment.TEMPORARY = -1;
  Segment.EPSILON   = 0.01;

  // Class methods
  Segment.prototype = {
    constructor:Segment,
    // Reverse order of the 2 points of this segment
    reverse:function () {
      const p   = this.p1;
      this.p1 = this.p2;
      this.p2 = p;
    },
    // 3D Length in space
    length3d:function () {
      this.lg3d = Math.sqrt((this.p1.x - this.p2.x) * (this.p1.x - this.p2.x)
        + (this.p1.y - this.p2.y) * (this.p1.y - this.p2.y)
        + (this.p1.z - this.p2.z) * (this.p1.z - this.p2.z));
      return this.lg3d;
    },
    // 2D Length in flat view
    length2d:function () {
      this.lg2d = Math.sqrt(
        (this.p1.xf - this.p2.xf) * (this.p1.xf - this.p2.xf)
        + (this.p1.yf - this.p2.yf) * (this.p1.yf - this.p2.yf));
      return this.lg2d;
    },
    // String representation
    toString:function () {
      return "S(P1:"+this.p1.toXYZString()+" "+this.p1.toXYString()+", P2:"+this.p2.toXYZString()+" "+this.p2.toXYString()+")";
      // +" type:"+this.type+" angle:"+this.angle
      // +" 2d:"+this.lg2d+" 3d:"+this.lg3d+" "
      // +" L="+faceLeft+" R="+faceRight+")";
    }
  };

  // Static methods
  // Compares segments s1 with s2
  Segment.compare = function (s1, s2) {
    var d = Point.compare3d(s1.p1, s2.p1) + Point.compare3d(s2.p2, s2.p2);
    return d > 1 ? d : 0;
  };
  // 2D Distance between Segment and Point @testOK
  Segment.distanceToSegment = function (seg, pt) {
    var x1 = seg.p1.x;
    var y1 = seg.p1.y;
    var x2 = seg.p2.x;
    var y2 = seg.p2.y;
    var x = pt.x;
    var y = pt.y;
    var l2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    var r = ((y1 - y) * (y1 - y2) + (x1 - x) * (x1 - x2)) / l2;
    var s = ((y1 - y) * (x2 - x1) - (x1 - x) * (y2 - y1)) / l2;
    var d = 0;
    if (r <= 0) {
      d = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    } else if (r >= 1) {
      d = Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));
    } else {
      d = (Math.abs(s) * Math.sqrt(l2));
    }
    return d;
  };

  // Closest points from s1 to s2 returned as a new segment
  Segment.closestSeg = function closestSeg(s1, s2) {
    // On this segment we have : S1(t1)=p1+t1*(p2-p1)       = p1+t1*v1   = p
    // On v argument we have   : S2(t2)=v.p1+t2*(v.p2-v.p1) = s2.p2+t2*v2 = q
    // Vector pq perpendicular to both lines : pq(t1,t2).v1=0  pq(t1,t2).v2=0
    // Cramer system :
    // (v1.v1)*t1 - (v1.v2)*t2 = -v1.r <=> a*t1 -b*t2 = -c
    // (v1.v2)*t1 - (v2.v2)*t2 = -v2.r <=> b*t1 -e*t2 = -f
    // Solved to t1=(bf-ce)/(ae-bb) t2=(af-bc)/(ae-bb)
    var t1;
    var t2;
    // s1 direction
    var v1 = new Point(s1.p2.x - s1.p1.x, s1.p2.y - s1.p1.y, s1.p2.z - s1.p1.z);
    // s2 direction
    var v2 = new Point(s2.p2.x - s2.p1.x, s2.p2.y - s2.p1.y, s2.p2.z - s2.p1.z);
    // s2.p1 to s1.p1
    var r = new Point(s1.p1.x - s2.p1.x, s1.p1.y - s2.p1.y, s1.p1.z - s2.p1.z);
    var a = Point.dot(v1,v1); // squared length of s1
    var e = Point.dot(v2,v2); // squared length of s2
    var f = Point.dot(v2,r);  //
    // Check degeneration of segments into points
    if (a <= Segment.EPSILON && e <= Segment.EPSILON) {
      // Both degenerate into points
      t1 = t2 = 0.0;
      return new Segment(s1.p1, s2.p1, Segment.TEMPORARY);
    }
    if (a <= Segment.EPSILON) {
      // This segment degenerate into point
      t1 = 0.0;
      t2 = f / e; // t1=0 => t2 = (b*t1+f)/e = f/e
      t2 = t2 < 0 ? 0 : t2 > 1 ? 1 : t2;
    } else {
      var c = Point.dot(v1, r);
      if (e <= Segment.EPSILON) {
        // Second segment degenerate into point
        t2 = 0.0;
        t1 = -c / a; // t2=0 => t1 = (b*t2-c)/a = -c/a
        t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
      } else {
        // General case
        var b = Point.dot(v1, v2); // Delayed computation of b
        var denom = a * e - b * b; // Denominator of Cramer system
        // Segments not parallel, compute closest and clamp
        if (denom !== 0.0) {
          t1 = (b * f - c * e) / denom;
          t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
        }
        else {
          // Arbitrary point, here 0 => p1
          t1 = 0;
        }
        // Compute closest on L2 using
        t2 = (b * t1 + f) / e;
        // if t2 in [0,1] done, else clamp t2 and recompute t1
        if (t2 < 0.0) {
          t2 = 0;
          t1 = -c / a;
          t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
        }
        else if (t2 > 1.0) {
          t2 = 1.0
          ;
          t1 = (b - c) / a;
          t1 = t1 < 0 ? 0 : t1 > 1 ? 1 : t1;
        }
      }
    }
    var c1 = Point.add(s1.p1, v1.scale(t1)); // c1 = p1+t1*(p2-p1)
    var c2 = Point.add(s2.p1, v2.scale(t2)); // c2 = p1+t2*(p2-p1)
    return new Segment(c1, c2);
  };

  // Closest points from s1(line) to s2(line) returned as a new segment
  Segment.closestLine = function closestLine(s1, s2) {
    // On s1 segment we have : S1(t1)=p1+t1*(p2-p1)       = p1+t1*v1   = p
    // On s2 segment we have : S2(t2)=v.p1+t2*(v.p2-v.p1) = s2.p2+t2*v2 = q
    // Vector pq perpendicular to both lines : pq(t1,t2).v1=0  pq(t1,t2).v2=0
    // Cramer system :
    // (v1.v1)*t1 - (v1.v2)*t2 = -v1.r <=> a*t1 -b*t2 = -c
    // (v1.v2)*t1 - (v2.v2)*t2 = -v2.r <=> b*t1 -e*t2 = -f
    // Solved to t1=(bf-ce)/(ae-bb) t2=(af-bc)/(ae-bb)
    var t1;
    var t2;
    var v1 = new Point(s1.p2.x - s1.p1.x, s1.p2.y - s1.p1.y, s1.p2.z - s1.p1.z); // s1 direction
    var v2 = new Point(s2.p2.x - s2.p1.x, s2.p2.y - s2.p1.y, s2.p2.z - s2.p1.z); // s direction
    var r = new Point(s1.p1.x - s2.p1.x, s1.p1.y - s2.p1.y, s1.p1.z - s2.p1.z); // s2.p1 to s1.p1
    var a = Point.dot(v1, v1); // squared length of s1
    var e = Point.dot(v2, v2); // squared length of s
    var f = Point.dot(v2, r);  //
    // Check degeneration of segments into points
    if (a <= Segment.EPSILON && e <= Segment.EPSILON) {
      // Both degenerate into points
      t1 = t2 = 0.0;
      return new Segment(s1.p1, s2.p1, Segment.TEMPORARY, -1);
    }
    if (a <= Segment.EPSILON) {
      // This segment degenerate into point
      t1 = 0.0;
      t2 = f / e; // t1=0 => t2 = (b*t1+f)/e = f/e
    } else {
      var c = Point.dot(v1, r);
      if (e <= Segment.EPSILON) {
        // Second segment degenerate into point
        t2 = 0.0;
        t1 = -c / a; // t2=0 => t1 = (b*t2-c)/a = -c/a
      } else {
        // General case
        var b = Point.dot(v1, v2); // Delayed computation of b
        var denom = a * e - b * b; // Denominator of cramer system
        // Segments not parallel, compute closest
        if (denom !== 0.0) {
          t1 = (b * f - c * e) / denom;
        }
        else {
          // Arbitrary point, here 0 => p1
          t1 = 0;
        }
        // Compute closest on L2 using
        t2 = (b * t1 + f) / e;
      }
    }
    var c1 = Point.add(s1.p1, v1.scale(t1)); // c1 = p1+t1*(p2-p1)
    var c2 = Point.add(s2.p1, v2.scale(t2)); // c2 = p1+t2*(p2-p1)
    return new Segment(c1, c2);
  };

  // For Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Segment;
  }
</script>
<script id="Face.js" type="application/javascript">
  // File: js/Face.js
  // Dependencies : import them before Face.js in browser
  if (typeof module !== 'undefined' && module.exports) {
    const Point = require('./Point.js');
  }

  // Face contains points, segments, normal
  function Face() {
    this.points    = [];
    this.normal    = [0, 0, 1];
    this.select    = 0;
    this.highlight = false;
    this.offset    = 0;
  }
  // Static values

  // Class methods
  Face.prototype = {
    constructor: Face,

    // Compute Face normal
    computeFaceNormal: function () {
      if (this.points.length < 3) {
        console.log("Warn Face < 3pts:" + this);
        return null;
      }
      for (let i = 0; i < this.points.length - 2; i++) {
        // Take triangles until p2p1 x p1p3 > 0.1
        let p1         = this.points[i];
        let p2         = this.points[i + 1];
        let p3         = this.points[i + 2];
        let u          = [p2.x - p1.x, p2.y - p1.y, p2.z - p1.z];
        let v          = [p3.x - p1.x, p3.y - p1.y, p3.z - p1.z];
        this.normal[0] = u[1] * v[2] - u[2] * v[1];
        this.normal[1] = u[2] * v[0] - u[0] * v[2];
        this.normal[2] = u[0] * v[1] - u[1] * v[0];
        if (Math.abs(this.normal[0]) + Math.abs(this.normal[1]) + Math.abs(this.normal[2]) > 0.1) {
          break;
        }
      }
      this.normalize(this.normal);
      return this.normal;
    },

    // Normalize vector v[3] = v[3]/||v[3]||
    normalize: function (v) {
      let d = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
      v[0] /= d;
      v[1] /= d;
      v[2] /= d;
    },

    // String representation
    toString: function () {
      let str = "F" + "(";
      this.points.forEach(function (p, i, a) {
        str = str + "P" + i + p.toString()+ (i === a.length - 1 ? "": " ");
      });
      str = str + ")";
      return str;
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Face;
  }
  </script>
<script id="Interpolator.js" type="application/javascript">
  // File: js/Interpolator.js
  // Dependencies : import them before Command in browser
  if (typeof module !== 'undefined' && module.exports) {
    // No dependencies
  }

  // Maps time to time
  // interpolate(tn) returns t for tn.
  // t and tn should start at 0.0 and end at 1.0
  // between 0 and 1, t can be < 0 (anticipate) and >1 (overshoot)
  // Use Padé approximations to speed up complex calculations
  var Interpolator = {
    // Linear "il"
    LinearInterpolator:function (t) {
      return t;
    },
    // Starts and ends slowly accelerate between "iad"
    /** @return {number} */
    AccelerateDecelerateInterpolator:function (t) {
      return (Math.cos((t + 1) * Math.PI) / 2.0) + 0.5;
    },
    // Model of a spring with overshoot "iso"
    /** @return {number} */
    SpringOvershootInterpolator:function (t) {
      if (t < 0.1825)
        return (((-237.110 * t) + 61.775) * t + 3.664) * t + 0.000;
      if (t < 0.425)
        return (((74.243 * t) - 72.681) * t + 21.007) * t - 0.579;
      if (t < 0.6875)
        return (((-16.378 * t) + 28.574) * t - 15.913) * t + 3.779;
      if (t < 1.0)
        return (((5.120 * t) - 12.800) * t + 10.468) * t - 1.788;
      return (((-176.823 * t) + 562.753) * t - 594.598) * t + 209.669;
    },
    // Model of a spring with bounce "isb"
    // 1.0-Math.exp(-4.0*t)*Math.cos(2*Math.PI*t)
    /** @return {number} */
    SpringBounceInterpolator:function (t) {
      var x = 0.0;
      if (t < 0.185)
        x = (((-94.565 * t) + 28.123) * t + 2.439) * t + 0.000;
      else if (t < 0.365)
        x = (((-3.215 * t) - 4.890) * t + 5.362) * t + 0.011;
      else if (t < 0.75)
        x = (((5.892 * t) - 10.432) * t + 5.498) * t + 0.257;
      else if (t < 1.0)
        x = (((1.520 * t) - 2.480) * t + 0.835) * t + 1.125;
      else x = (((-299.289 * t) + 945.190) * t - 991.734) * t + 346.834;
      return x > 1 ? 2 - x : x;
    },
    // Model of a gravity with bounce "igb"
    // a = 8.0, k=1.5; x=(a*t*t-v0*t)*Math.exp(-k*t);
    /** @return {number} */
    GravityBounceInterpolator:function (t) {
      var x = 0.0;
      if (t < 0.29)
        x = (((-14.094 * t) + 9.810) * t - 0.142) * t + 0.000;
      else if (t < 0.62)
        x = (((-16.696 * t) + 21.298) * t - 6.390) * t + 0.909;
      else if (t < 0.885)
        x = (((31.973 * t) - 74.528) * t + 56.497) * t + -12.844;
      else if (t < 1.0)
        x = (((-37.807 * t) + 114.745) * t - 114.938) * t + 39.000;
      else x = (((-7278.029 * t) + 22213.034) * t - 22589.244) * t + 7655.239;
      return x > 1 ? 2 - x : x;
    },
    // Bounce at the end "ib"
    /** @return {number} */
    BounceInterpolator:function (t) {
      function bounce(t) {
        return t * t * 8.0;
      }
      t *= 1.1226;
      if (t < 0.3535) return bounce(t);
      else if (t < 0.7408) return bounce(t - 0.54719) + 0.7;
      else if (t < 0.9644) return bounce(t - 0.8526) + 0.9;
      else return bounce(t - 1.0435) + 0.95;
    },
    // Overshoot "io"
    /** @return {number} */
    OvershootInterpolator:function (t) {
      const mTension = 2;
      t -= 1.0;
      return t * t * ((mTension + 1) * t + mTension) + 1.0;
    },
    // Anticipate "ia"
    /** @return {number} */
    AnticipateInterpolator:function (t) {
      const mTension = 0; // 2
      return t * t * ((mTension + 1) * t - mTension);
    },
    // Anticipate Overshoot "iao"
    /** @return {number} */
    AnticipateOvershootInterpolator:function (t) {
      const mTension = 1.5;
      function a(t, s) {
        return t * t * ((s + 1) * t - s);
      }
      function o(t, s) {
        return t * t * ((s + 1) * t + s);
      }
      if (t < 0.5) return 0.5 * a(t * 2.0, mTension);
      else return 0.5 * (o(t * 2.0 - 2.0, mTension) + 2.0);
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Interpolator;
  }
</script>
<script id="Model.js" type="application/javascript">
  // File: js/Model.js
  // Dependencies : import them before Model.js in browser
  if (typeof module !== 'undefined' && module.exports) {
    var Point   = require('./Point.js');
    var Segment = require('./Segment.js');
    var Face    = require('./Face.js');
    var Plane   = require('./Plane.js');
  }

  // Model to hold Points, Segments, Faces
  function Model() {
    // Arrays to hold points, faces, segments
    this.points   = [];
    this.segments = [];
    this.faces    = [];
  }

  // Class methods
  Model.prototype = {
    constructor:Model,

    // Initializes this orModel with XY points CCW @testOK
    init:function (list) {
      this.points   = [];
      this.segments = [];
      this.faces    = [];
      this.change   = true; // should trigger a redraw
      var f         = new Face();
      // Add XY XYZ points, make EDGE segments
      var p1        = null;
      for (var i = 0; i < list.length; i += 2) {
        var p2 = this.addPointXYZ(list[i], list[i + 1], list[i], list[i + 1], 0);
        f.points.push(p2);
        if (p1 !== null) {
          this.addSegment(p1, p2, Segment.EDGE);
        }
        p1 = p2;
      }
      this.addSegment(p1, f.points[0], Segment.EDGE);
      this.addFace(f);
      return this;
    },
    // Adds a point to this Model or return the point at x,y @testOK
    addPointXYZ: function (xf,yf, x,y,z) {
      // Create a new Point
      var p = null;
      if (arguments.length === 2) {
        p = new Point(xf, yf);
      } else if (arguments.length === 3) {
        p = new Point(x, y, z);
      } else if (arguments.length === 5) {
        p = new Point(xf, yf, x, y, z);
      } else {
        console.log("Warn wrong number of Args for addPointXYZ")
      }
      this.points.push(p);
      return p;
    },
    // Adds a point to this Model or return existing point @testOK
    addPoint:function (pt) {
      // Search existing points
      for (var i = 0; i < this.points.length; i++) {
        if (Point.compare3d(this.points[i], pt) < 1) {
          // Return existing point instead of pt parameter
          return this.points[i];
        }
      }
      // Add new Point if not already in model
      this.points.push(pt);
      return pt;
    },
    // Adds a segment to this model @testOK
    addSegment:function (p1, p2, type) {
      if (Point.compare3d(p1, p2) === 0) {
        console.log("Warn Add degenerate segment:" + p1);
        console.log(new Error().stack);
        return null;
      }
      var s = new Segment(p1, p2, type);
      this.segments.push(s);
      return s;
    },
    // Adds a face to this model @testOK
    addFace:function (f) {
      // TODO search existing faces
      this.faces.push(f);
      return f;
    },
    // Align Point p on segment s in 2D from coordinates in 3D @testOK
    align2dFrom3d:function (p, s) {
      // Compute the length from p1 to p in 3D
      var lg3d = Math.sqrt((s.p1.x - p.x) * (s.p1.x - p.x)
        + (s.p1.y - p.y) * (s.p1.y - p.y)
        + (s.p1.z - p.z) * (s.p1.z - p.z));
      // Compute ratio with the segment length
      var t    = lg3d / s.length3d();
      // Set 2D to have the same ratio
      p.xf     = s.p1.xf + t * (s.p2.xf - s.p1.xf);
      p.yf     = s.p1.yf + t * (s.p2.yf - s.p1.yf);
    },
    // Find face on the right of segment a b @testOK
    faceRight:function (a, b) {
      if (b === undefined) {
        // Guess we have a segment instead of two points
        b = a.p2;
        a = a.p1;
      }
      var ia    = 0, ib = 0;
      var right = null;
      this.faces.forEach(function (f) {
        // Both points are in face
        if (((ia = f.points.indexOf(a)) >= 0)
          && ((ib = f.points.indexOf(b)) >= 0)) {
          // a is after b, the face is on the right
          if (ia === ib + 1 || (ib === f.points.length - 1 && ia === 0)) {
            right = f;
          }
        }
      });
      return right;
    },
    // Find face on the left @testOK
    faceLeft:function (a, b) {
      if (b === undefined) {
        // Guess we have a segment instead of two points
        b = a.p2;
        a = a.p1;
      }
      var ia, ib;
      var left = null;
      this.faces.forEach(function (f) {
        // Both points are in face
        if (((ia = f.points.indexOf(a)) >= 0)
          && ((ib = f.points.indexOf(b)) >= 0)) {
          // b is after a, the face is on the left
          if (ib === ia + 1 || (ia === f.points.length - 1 && ib === 0)) {
            left = f;
          }
        }
      });
      return left;
    },
    // Search face containing a and b but which is not f0 @testOK
    searchFace:function (s, f0) {
      var a     = s.p1;
      var b     = s.p2;
      var found = null;
      this.faces.forEach(function (f) {
        if (f0 === null
          && (f.points.indexOf(a) > -1)
          && (f.points.indexOf(b) > -1)) {
          found = f;
        }
        else if (f !== f0
          && (f.points.indexOf(a)) > -1
          && (f.points.indexOf(b) > -1)) {
          found = f;
        }
      });
      return found;
    },

    // Compute angle between face left and right of a segment, angle is positive  @testOK
    computeAngle:function (s) {
      var a     = s.p1;
      var b     = s.p2;
      // Find faces left and right
      var left  = this.faceLeft(a, b);
      var right = this.faceRight(a, b);
      // Compute angle in Degrees at this segment
      if (s.type === Segment.EDGE) {
        console.log("Warn Angle on Edge:" + s);
        console.log(new Error().stack);
        return 0;
      }
      if (right === null || left === null) {
        console.log("Warn No right and left face for:" + s + " left:" + left + " right:" + right);
        console.log(new Error().stack);
        return 0;
      }
      var nL  = left.computeFaceNormal();
      var nR  = right.computeFaceNormal();
      // Cross product nL nR
      var cx  = nL[1] * nR[2] - nL[2] * nR[1], cy = nL[2] * nR[0] - nL[0] * nR[2], cz = nL[0] * nR[1] - nL[1] * nR[0];
      // Segment vector
      var vx  = s.p2.x - s.p1.x, vy = s.p2.y - s.p1.y, vz = s.p2.z - s.p1.z;
      // Scalar product between segment and cross product, normed
      var sin = (cx * vx + cy * vy + cz * vz) /
        Math.sqrt(vx * vx + vy * vy + vz * vz);
      // Scalar between normals
      var cos = nL[0] * nR[0] + nL[1] * nR[1] + nL[2] * nR[2];
      if (cos > 1.0)
        cos = 1.0;
      if (cos < -1.0)
        cos = -1.0;
      s.angle = Math.acos(cos) / Math.PI * 180.0;
      if (Number.isNaN(s.angle)) {
        s.angle = 0.0;
      }
      if (sin < 0)
        s.angle = -s.angle;
      // Follow the convention folding in front is positive
      s.angle = -s.angle;
      return s.angle;
    },
    // Search segment containing Points a and b @testOK
    searchSegmentTwoPoints:function (a, b) {
      var list = [];
      this.segments.forEach(function (s) {
        if ((Point.compare3d(s.p1, a) === 0 && Point.compare3d(s.p2, b) === 0)
          ||(Point.compare3d(s.p2, a) === 0 && Point.compare3d(s.p1, b) === 0) )
          list.push(s);
      });
      if (list.length > 1) {
        console.log("Error More than one segment on 2 points:" + list.length
          + " " + list[0].p1 + list[0].p2 + " " + list[1].p1 + list[1].p2);
        console.log(new Error().stack);
      }
      if (list.length === 0)
        return null;
      return list[0];
    },
    // Search segments containing Point a @testOK
    searchSegmentsOnePoint:function (a) {
      var list = [];
      this.segments.forEach(function (s) {
        if (s.p1 === a || s.p2 === a)
          list.push(s);
      });
      return list;
    },

    // Splits Segment by a point @testOK
    splitSegmentByPoint:function (s, p) {
      // No new segment if on ending point
      if (Point.compare3d(s.p1, p) === 0 || Point.compare3d(s.p2, p) === 0) {
        return s;
      }
      // Create new Segment
      var s1 = this.addSegment(p, s.p2, s.type);
      // Shorten s
      s.p2   = p;
      s.length2d();
      s.length3d();
      return s1;
    },
    // Split segment on a point, add point to model, update faces containing segment @testOK
    splitSegmentOnPoint:function (s1, p) {
      // Align Point p on segment s in 2D from coordinates in 3D
      this.align2dFrom3d(p, s1);
      // Add point P to first face.
      var l = this.searchFace(s1, null);
      if (l !== null && l.points.indexOf(p) === -1) {
        // Add after P2 or P1 for the left face (CCW)
        var pts = l.points;
        for (var i = 0; i < pts.length; i++) {
          if (pts[i] === s1.p1
            && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p2) {
            pts.splice(i + 1, 0, p);
            break;
          }
          if (pts[i] === s1.p2
            && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p1) {
            pts.splice(i + 1, 0, p);
            break;
          }
        }
      }
      // Add point P to second face.
      var r = this.searchFace(s1, l);
      if (r !== null && r.points.indexOf(p) === -1) {
        var pts = r.points;
        // Add after P2 or P1 for the right face (CCW)
        for (var i = 0; i < pts.length; i++) {
          if (pts[i] === s1.p1 && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p2) {
            pts.splice(i + 1, 0, p);
            break;
          }
          if (pts[i] === s1.p2 && pts[i === pts.length - 1 ? 0 : i + 1] === s1.p1) {
            pts.splice(i + 1, 0, p);
            break;
          }
        }
      }
      // Add this as a new point to the model
      this.addPoint(p);
      // Now we can shorten s to p
      this.splitSegmentByPoint(s1, p);
      return s1;
    },
    // Splits Segment by a ratio k in  ]0 1[ counting from p1 @testOK
    splitSegmentByRatio:function (s, k) {
      // Create new Point
      var p = new Point();
      p.set3d(
        s.p1.x + k * (s.p2.x - s.p1.x),
        s.p1.y + k * (s.p2.y - s.p1.y),
        s.p1.z + k * (s.p2.z - s.p1.z));
      this.splitSegmentOnPoint(s, p);
    },

    // Origami
    // Split Face f by plane pl @testOK except on <:> denerate poly
    // Complex by design
    splitFaceByPlane:function (f1, pl) {
      var front     = []; // Front side
      var back      = []; // Back side
      var inFront   = false; // Front face with at least one point
      var inBack    = false;  // Back face with at least one point
      var lastinter = null; // Last intersection

      // Begin with last point
      var a     = f1.points[f1.points.length - 1];
      var aSide = pl.classifyPointToPlane(a);
      for (var n = 0; n < f1.points.length; n++) {
        // Segment from previous 'a'  to current 'b'
        // 9 cases : behind -1, on 0, in front +1
        // Push to front and back
        //  	  a  b Inter front back
        // c1) -1  1 i     i b   i    bf
        // c2)  0  1 a     b     .    of
        // c3)  1  1 .     b     .    ff
        // c4)  1 -1 i     i     i b  fb
        // c5)  0 -1 a     .     a b  ob ??
        // c6) -1 -1 .           b    bb
        // c7)  1  0 b     b     .    fo
        // c8)  0  0 a b   b     .    oo
        // c9) -1  0 b     b     b    bo
        var b     = f1.points[n];
        var bSide = pl.classifyPointToPlane(b);
        if (bSide === 1) {    // b in front
          if (aSide === -1) { // a behind
            // c1) b in front, a behind => edge cross bf
            var j = pl.intersectPoint(b, a);
            // Add i to model points
            var i = this.addPoint(j);
            // Add 'i' to front and back sides
            front.push(i);
            back.push(i);
            // Examine segment a,b to split (can be null if already split)
            var s     = this.searchSegmentTwoPoints(a, b);
            var index = this.segments.indexOf(s);
            if (index !== -1) {
              // Set i 2D coordinates from 3D
              this.align2dFrom3d(i, s);
              // Add new segment
              this.addSegment(i, b, Segment.PLAIN);
              // Modify existing set b = i
              // this.segments.splice(index, 1); has drawback
              if (s.p1 === a) {
                s.p2 = i;
              }
              else {
                s.p1 = i;
              }
            }
            // Eventually add segment from last intersection
            if (lastinter !== null) {
              this.addSegment(lastinter, i, Segment.PLAIN);
              lastinter = null;
            } else {
              lastinter = i;
            }
          }
          else if (aSide === 0) {
            // c2) 'b' in front, 'a' on
            lastinter = a;
          }
          else if (aSide === 1) {
            // c3) 'b' in front 'a' in front
          }
          // In all 3 cases add 'b' to front side
          front.push(b);
          inFront = true;
        }
        else if (bSide === -1) {  // b behind
          if (aSide === 1) {        // a in front
            // c4) edge cross add intersection to both sides
            var j = pl.intersectPoint(b, a);
            // Add i to model points
            var i = this.addPoint(j);
            // Add 'i' to front and back sides
            front.push(i);
            back.push(i);
            // Examine segment a,b to split
            var s     = this.searchSegmentTwoPoints(a, b);
            var index = this.segments.indexOf(s);
            if (index !== -1) {
              // Set i 2D coordinates from 3D
              this.align2dFrom3d(i, s);
              // Add new segment
              this.addSegment(i, b, Segment.PLAIN);
              // Modify existing
              // this.segments.splice(index, 1); has drawback
              if (s.p1 === a) {
                s.p2 = i;
              } else {
                s.p1 = i;
              }
            }
            // Eventually add segment from last inter
            if (lastinter !== null && i !== lastinter) {
              this.addSegment(lastinter, i);
              lastinter = null;
            } else {
              lastinter = i;
            }
          }
          else if (aSide === 0) {
            // c5) 'a' on 'b' behind
            if (back[back.length - 1] !== a){
              back.push(a);
            }
            // Eventually add segment from last inter
            if (lastinter !== null && lastinter !== a) {
              this.addSegment(lastinter, a, Segment.PLAIN);
              lastinter = null;
            } else {
              lastinter = a;
            }
          }
          else if (aSide === -1) {
            // c6) 'a' behind 'b' behind
          }
          // In all 3 cases add current point 'b' to back side
          back.push(b);
          inBack = true;
        }
        else if (bSide === 0) {   // b on
          if (aSide === 1) {
            // c7) 'a' front 'b' on
          }
          if (aSide === 0) {
            // c8) 'a' on 'b' on
          }
          if (aSide === -1) {       // a behind
            // c9 'a' behind 'b' on
            back.push(b);
            // Eventually add segment from last inter
            if (lastinter !== null && lastinter !== b) {
              var s = this.searchSegmentTwoPoints(lastinter, b);
              if (s === null) {
                this.addSegment(lastinter, b, Segment.PLAIN);
              }
              lastinter = null;
            } else {
              lastinter = b;
            }
          }
          // In all 3 cases, add 'b' to front side
          front.push(b);
        }
        // Next edge
        a     = b;
        aSide = bSide;
      }
      // Modify initial face f1 and add new face if not degenerated
      // this.faces.splice(this.faces.indexOf(f1), 1); change Array
      if (inFront) {
        f1.points = front;
        f1        = null;
      }
      if (inBack) {
        if (f1 !== null) {
          f1.points = back;
        } else {
          var f    = new Face();
          f.points = back;
          this.faces.push(f);
        }
      }
    },
    // Split all or given Faces by a plane @testOK
    splitFacesByPlane:function (pl, list) {
      // Split list or all faces
      list = (list !== undefined) ? list : this.faces;
      // When a face is split, one face is modified in Array and one added, at the end
      for (var i = list.length - 1; i > -1; i--) {
        var f = list[i];
        this.splitFaceByPlane(f, pl);
      }
    },
    // Split all or given faces Across two points @testOK
    splitCross:function (p1, p2, list) {
      var pl = Plane.across(p1, p2);
      this.splitFacesByPlane(pl, list);
    },
    // Split all or given faces By two points @testOK
    splitBy:function (p1, p2, list) {
      var pl = Plane.by(p1, p2);
      this.splitFacesByPlane(pl, list);
    },
    // Split faces by a plane Perpendicular to a Segment passing by a Point "p" @testOK
    splitOrtho:function (s, p, list) {
      var pl = Plane.ortho(s, p);
      this.splitFacesByPlane(pl, list);
    },
    // Split faces by a plane between two segments given by 3 points p1 center @testOK
    splitLineToLineByPoints:function (p0, p1, p2, list) {
      // Project p0 on p1 p2
      var p0p1 = Math.sqrt((p1.x - p0.x) * (p1.x - p0.x)
        + (p1.y - p0.y) * (p1.y - p0.y)
        + (p1.z - p0.z) * (p1.z - p0.z));
      var p1p2 = Math.sqrt((p1.x - p2.x) * (p1.x - p2.x)
        + (p1.y - p2.y) * (p1.y - p2.y)
        + (p1.z - p2.z) * (p1.z - p2.z));
      var k    = p0p1 / p1p2;
      var x    = p1.x + k * (p2.x - p1.x);
      var y    = p1.y + k * (p2.y - p1.y);
      var z    = p1.z + k * (p2.z - p1.z);
      // e is on p1p2 symmetric of p0
      var e    = new Point(x, y, z);
      // Define Plane
      var pl   = Plane.by(p0, e);
      this.splitFacesByPlane(pl, list);
    },
    // Split faces by a plane between two segments @testOK
    splitLineToLine:function (s1, s2, list) {
      var s = Segment.closestLine(s1, s2);
      if (s.length3d() < 1) {
        // Segments cross at c Center
        var c = s.p1;
        var a = Point.sub(s1.p1, c).length() > Point.sub(s1.p2, c).length() ? s1.p1 : s1.p2;
        var b = Point.sub(s2.p1, c).length() > Point.sub(s2.p2, c).length() ? s2.p1 : s2.p2;
        this.splitLineToLineByPoints(a, c, b, list);
      } else {
        // Segments do not cross, parallel
        var pl = Plane.across(s.p1, s.p2);
        this.splitFacesByPlane(pl, list);
      }
    },

    // Rotate around axis Segment by angle a list of Points @testOK
    rotate:function (s, angle, list) {
      var angleRd = angle * Math.PI / 180.0;
      var ax      = s.p1.x, ay = s.p1.y, az = s.p1.z;
      var nx      = s.p2.x - ax, ny = s.p2.y - ay, nz = s.p2.z - az;
      var n       = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
      nx *= n;
      ny *= n;
      nz *= n;
      var sin     = Math.sin(angleRd), cos = Math.cos(angleRd);
      var c1      = 1.0 - cos;
      var c11     = c1 * nx * nx + cos, c12 = c1 * nx * ny - nz * sin, c13 = c1 * nx * nz + ny * sin;
      var c21     = c1 * ny * nx + nz * sin, c22 = c1 * ny * ny + cos, c23 = c1 * ny * nz - nx * sin;
      var c31     = c1 * nz * nx - ny * sin, c32 = c1 * nz * ny + nx * sin, c33 = c1 * nz * nz + cos;
      list.forEach(function (p) {
        var ux = p.x - ax, uy = p.y - ay, uz = p.z - az;
        p.x    = ax + c11 * ux + c12 * uy + c13 * uz;
        p.y    = ay + c21 * ux + c22 * uy + c23 * uz;
        p.z    = az + c31 * ux + c32 * uy + c33 * uz;
      });
    },
    // Turn model around axis by  angle @testOK
    turn:function (axe, angle) {
      angle *= Math.PI / 180.0;
      var ax = 0, ay = 0, az = 0;
      var nx = 0.0;
      var ny = 0.0;
      var nz = 0.0;
      if (axe === 1) {
        nx = 1.0;
      }
      else if (axe === 2) {
        ny = 1.0;
      }
      else if (axe === 3) {
        nz = 1.0;
      }
      var n   = (1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz));
      nx *= n;
      ny *= n;
      nz *= n;
      var sin = Math.sin(angle);
      var cos = Math.cos(angle);
      var c1  = 1.0 - cos;
      var c11 = c1 * nx * nx + cos, c12 = c1 * nx * ny - nz * sin, c13 = c1 * nx * nz + ny * sin;
      var c21 = c1 * ny * nx + nz * sin, c22 = c1 * ny * ny + cos, c23 = c1 * ny * nz - nx * sin;
      var c31 = c1 * nz * nx - ny * sin, c32 = c1 * nz * ny + nx * sin, c33 = c1 * nz * nz + cos;
      this.points.forEach(function (p) {
        var ux = p.x - ax, uy = p.y - ay, uz = p.z - az;
        p.x    = ax + c11 * ux + c12 * uy + c13 * uz;
        p.y    = ay + c21 * ux + c22 * uy + c23 * uz;
        p.z    = az + c31 * ux + c32 * uy + c33 * uz;
      });
    },

    // Adjust one Point on its (eventually given) segments @testOK
    adjust:function (p, segments) {
      // Take all segments containing point p or given list
      var segs = segments || this.searchSegmentsOnePoint(p);
      var dmax = 100;
      // Kaczmarz or Verlet
      // Iterate while length difference between 2d and 3d is > 1e-3
      for (var i = 0; dmax > 0.001 && i < 20; i++) {
        dmax = 0;
        // Iterate over all segments
        // Pm is the medium point
        var pm = new Point(0, 0, 0);
        for (var j = 0; j < segs.length; j++) {
          var s = segs[j];
          var lg3d = s.length3d();
          var lg2d = s.length2d(); // Should not change
          var d    = (lg2d - lg3d);
          if (Math.abs(d) > dmax) {
            dmax = Math.abs(d);
          }
          // Move B Bnew = A + AB * r With r = l2d/l3d
          // AB * r is the extension based on length3d to match length2d
          var r = (lg2d / lg3d);
          if (s.p2 === p) {
            // move p2
            pm.x += s.p1.x + (s.p2.x - s.p1.x) * r;
            pm.y += s.p1.y + (s.p2.y - s.p1.y) * r;
            pm.z += s.p1.z + (s.p2.z - s.p1.z) * r;
          } else if (s.p1 === p) {
            // move p1
            pm.x += s.p2.x + (s.p1.x - s.p2.x) * r;
            pm.y += s.p2.y + (s.p1.y - s.p2.y) * r;
            pm.z += s.p2.z + (s.p1.z - s.p2.z) * r;
          }
        }
        // Set Point with average position taking all segments
        if (segs.length !== 0) {
          p.x = pm.x / segs.length;
          p.y = pm.y / segs.length;
          p.z = pm.z / segs.length;
        }
      }
      return dmax;
    },
    // Adjust list of Points @testOK
    adjustList:function (list) {
      var dmax = 100;
      for (var i = 0; dmax > 0.001 && i < 100; i++) {
        dmax     = 0;
        for (var j = 0; j < list.length; j++) {
          var p = list[j];
          var segs = this.searchSegmentsOnePoint(p);
          var d = this.adjust(p, segs);
          if (Math.abs(d) > dmax) {
            dmax = Math.abs(d);
          }
        }
      }
      return dmax;
    },

    // Evaluate and highlight segments with wrong length
    evaluate:function () {
      // Iterate over all segments
      for (var i = 0; i < this.segments.length; i++) {
        var s = this.segments[i];
        var d = Math.abs(s.length2d() - s.length3d());
        if (d < 0.1) {
          s.highlight = false;
        } else {
          s.highlight = true;
        }
      }
    },
    // Select (highlight) points
    selectPts:function (pts) {
      pts.forEach(function (p) {
        p.select ^= true; // xor
      });
    },
    // Select (highlight) segments
    selectSegs:function (segs) {
      segs.forEach(function (s) {
        s.select ^= true; // xor
      });
    },

    // Move list of points by dx,dy,dz
    move:function (dx, dy, dz, pts) {
      pts = (pts === null) ? this.points : ((pts.length === 0) ? this.points : pts);
      pts.forEach(function (p) {
        p.x += dx;
        p.y += dy;
        p.z += dz;
      });
    },
    // Move on a point P0 all following points, k from 0 to 1 for animation
    moveOn:function (p0, k1, k2, pts) {
      pts.forEach(function (p) {
        p.x = p0.x * k1 + p.x * k2;
        p.y = p0.y * k1 + p.y * k2;
        p.z = p0.z * k1 + p.z * k2;
      });
    },
    // Move on a line S0 all following points, k from 0 to 1 for animation
    moveOnLine:function (s, k1, k2, pts) {
      pts.forEach(function (p) {
        // Point n = s0.closestLine(new Segment(p,p)).p1;
        // First case if there is a segment joining point p and s search point common pc
        var pc = null;
        var pd = null;
        this.segments.some(function (si) {
          if (si.equals(p, s.p1)) {
            pc = si.p2;
            pd = s.p2;
            return true;
          } else if (si.equals(p, s.p2)) {
            pc = si.p2;
            pd = s.p1;
            return true;
          } else if (si.equals(s.p1, p)) {
            pc = si.p1;
            pd = s.p2;
            return true;
          } else if (si.equals(s.p2, p)) {
            pc = si.p1;
            pd = s.p1;
            return true;
          }
        });
        // if we have pc point common and pd point distant
        if (pc !== null) {
          // Turn p on pc pd (keep distance from Pc to P)
          var pcp  = Math.sqrt((pc.x - p.x) * (pc.x - p.x)
            + (pc.y - p.y) * (pc.y - p.y)
            + (pc.z - p.z) * (pc.z - p.z));
          var pcpd = Math.sqrt((pc.x - pd.x) * (pc.x - pd.x)
            + (pc.y - pd.y) * (pc.y - pd.y)
            + (pc.z - pd.z) * (pc.z - pd.z));
          var k    = pcp / pcpd;
          p.x      = (pc.x + k * (pd.x - pc.x)) * k1 + p.x * k2;
          p.y      = (pc.y + k * (pd.y - pc.y)) * k1 + p.y * k2;
          p.z      = (pc.z + k * (pd.z - pc.z)) * k1 + p.z * k2;
        }
        // Second case
        else {
          // console.log("Second case"); Oui ça arrive sur le bateau
          // Project point
          var pp = s.closestLine(new Segment(p, p)).p1;
          // Move point p on projected pp
          p.x    = (p.x + (pp.x - p.x)) * k1 + p.x * k2;
          p.y    = (p.y + (pp.y - p.y)) * k1 + p.y * k2;
          p.z    = (p.z + (pp.z - p.z)) * k1 + p.z * k2;
        }
      }, this);
    },
    // Move given or all points to z = 0
    flat:function (pts) {
      var lp = pts.length === 0 ? this.points : pts;
      lp.forEach(function (p) {
        p.z = 0;
      });
    },
    // Offset by dz all following faces according to Z
    offset:function (dz, lf) {
      lf.forEach(function (f) {
        f.offset += dz;
      });
    },

    // 2D Boundary [xmin, ymin, xmax, ymax]*/
    get2DBounds:function () {
      var xmax = -100.0;
      var xmin = 100.0;
      var ymax = -100.0;
      var ymin = 100.0;
      this.points.forEach(function (p) {
        var x = p.xf, y = p.yf;
        if (x > xmax) xmax = x;
        if (x < xmin) xmin = x;
        if (y > ymax) ymax = y;
        if (y < ymin) ymin = y;
      });
      var obj = {};
      obj.xmin = xmin;
      obj.ymin =ymin;
      obj.xmax = xmax;
      obj.ymax = ymax;
      return obj;
    },
    // Fit the model to -200 +200
    zoomFit:function () {
      var b     = this.get3DBounds();
      var w     = 400;
      var scale = w / Math.max(b[2] - b[0], b[3] - b[1]);
      var cx    = -(b[0] + b[2]) / 2;
      var cy    = -(b[1] + b[3]) / 2;
      this.move(cx, cy, 0, null);
      this.scaleModel(scale);
    },
    // Scale model
    scaleModel:function (scale) {
      this.points.forEach(function (p) {
        p.x *= scale;
        p.y *= scale;
        p.z *= scale;
      });
    },
    // 3D Boundary View [xmin, ymin, xmax, ymax]
    get3DBounds:function () {
      var xmax = -200.0, xmin = 200.0;
      var ymax = -200.0, ymin = 200.0;
      this.points.forEach(function (p) {
        var x = p.x, y = p.y;
        if (x > xmax) xmax = x;
        if (x < xmin) xmin = x;
        if (y > ymax) ymax = y;
        if (y < ymin) ymin = y;
      });
      return [xmin, ymin, xmax, ymax]
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Model;
  }
</script>
<script id="Command.js" type="application/javascript">
  // File: js/Command.js
  // Dependencies : import them before Command.js in browser
  if (typeof module !== 'undefined' && module.exports) {
    var Model        = require('./Model.js');
    var Interpolator = require('./Interpolator.js');
  }

  // Interprets a list of commands, and apply them on Model
  function Command(model) {
    this.model        = model;
    this.toko         = [];
    this.done         = [];
    this.iTok         = 0;
    // State machine
    this.state        = State.idle;
    // Time interpolated at instant 'p' preceding and at instant 'n' current
    this.tni          = 1;
    this.tpi          = 0;
    this.interpolator = Interpolator.LinearInterpolator;
    // scale, ctx, cy, cz used in ZoomFit
    this.za           = [0, 0, 0, 0];
    // Interpolator used in anim() to map tn (time normalized) to tni (time interpolated)
    this.interpolator = Interpolator.LinearInterpolator;
    // Coefficient to multiply value given in Offset commands
    this.kOffset = 1; // 0.2 for real rendering, can be 10 to debug
  }

  // Static values
  const State = {idle:0, run:1, anim:2, pause:3, undo:4};
  // console.log(Object.keys(State)[1]); // run

  // Class methods
  Command.prototype = {
    constructor:Command,

    // Tokenize, split the String in this.toko Array of String @testOK
    tokenize:function (input) {
      var text  = input.replace(/[\);]/g, ' rparent');
      text      = text.replace(/,/g, ' ');
      text      = text.replace(/\/\/.*$/mg, '');
      this.toko = text.split(/\s+/);
      this.iTok = 0;
      return this.toko;
    },

    // Read a File @testOK
    readfile:function (filename) {
      var text = null;
      // If we are in NodeJS fs is required
      if (typeof require !== 'undefined') {
        const fs = require('fs');
        text     = fs.readFileSync(filename, 'utf-8');
      }
      // If we are in browser XHR or Script embedded
      else {
        const request = new XMLHttpRequest();
        request.onreadystatechange = function () {
          if (request.readyState === XMLHttpRequest.DONE && request.status === 200) {
            const type = request.getResponseHeader("Content-Type");
            if (type.match(/^text/)) { // Make sure response is text
              text = request.responseText;
            }
          } else if (request.readyState !== XMLHttpRequest.OPENED) {
            console.log("Error ? state:" + request.readyState + " status:" + request.status);
          }
        };
        // XMLHttpRequest.open(method, url, async)
        // Here async = false ! => Warning from Firefox, Chrome,
        request.open('GET', filename, false);
        request.send(null);
      }
      if (text === null) {
        console.log("Error reading:" + filename);
      }
      return text;
    },

    // Execute one command token on model
    execute:function () {
      // Commands
      // "d : define" @testOK
      if (this.toko[this.iTok] === "d" || this.toko[this.iTok] === "define") {
        // Define sheet by N points x,y CCW
        this.iTok++;
        var list = [];
        while (Number.isInteger(Number(this.toko[this.iTok]))) {
          list.push(this.toko[this.iTok++]);
        }
        this.model.init(list);
      }
      // Origami splits
      // "b : by" @testOK
      else if (this.toko[this.iTok] === "b" || this.toko[this.iTok] === "by") {
        // Split by two points
        this.iTok++;
        var a = this.model.points[this.toko[this.iTok++]];
        var b = this.model.points[this.toko[this.iTok++]];
        this.model.splitBy(a, b);
      }
      // "c : cross"  @testOK
      else if (this.toko[this.iTok] === "c" || this.toko[this.iTok] === "cross") {
        // Split across two points all (or just listed) faces
        this.iTok++;
        var a = this.model.points[this.toko[this.iTok++]];
        var b = this.model.points[this.toko[this.iTok++]];
        this.model.splitCross(a, b);
      }
      // "p : perpendicular"  @testOK
      else if (this.toko[this.iTok] === "p" || this.toko[this.iTok] === "perpendicular") {
        // Split perpendicular of line by point
        this.iTok++;
        var s = this.model.segments[this.toko[this.iTok++]];
        var p = this.model.points[this.toko[this.iTok++]];
        this.model.splitOrtho(s, p);
      }
      // "lol : LineOnLine" TODO test
      else if (this.toko[this.iTok] === "lol" || this.toko[this.iTok] === "lineonline") {
        // Split by a plane passing between segments
        this.iTok++;
        var s0 = this.model.segments[this.toko[this.iTok++]];
        var s1 = this.model.segments[this.toko[this.iTok++]];
        this.model.splitLineToLine(s0, s1);
      }
      // Segment split TODO test
      // "s : split seg numerator denominator"
      else if (this.toko[this.iTok] === "s" || this.toko[this.iTok] === "split") {
        // Split set by N/D
        this.iTok++;
        var s = this.model.segments[this.toko[this.iTok++]];
        var n = this.toko[this.iTok++];
        var d = this.toko[this.iTok++];
        this.model.splitSegmentByRatio(s, n / d);
      }

      // Animation commands use tni tpi
      // " r : rotate Seg Angle Points"
      else if (this.toko[this.iTok] === "r" || this.toko[this.iTok] === "rotate") {
        // Rotate Seg Angle Points with animation
        this.iTok++;
        var s     = this.model.segments[this.toko[this.iTok++]];
        var angle = (this.toko[this.iTok++] * (this.tni - this.tpi));
        var list  = this.listPoints();
        this.model.rotate(s, angle, list);
      }
      // "f : fold to angle"
      else if (this.toko[this.iTok] === "f" || this.toko[this.iTok] === "fold") {
        this.iTok++;
        var s = this.model.segments[this.toko[this.iTok++]];
        // Cache current angle at start of animation
        if (this.tpi === 0)
          this.angleBefore = this.model.computeAngle(s);
        var angle = ((this.toko[this.iTok++] - this.angleBefore) * (this.tni - this.tpi));
        var list = this.listPoints();
        // Reverse segment to have the first point on left face
        if (this.tpi === 0 && this.model.faceRight(s.p1, s.p2).points.indexOf(list[0]) !== -1)
          s.reverse();
        this.model.rotate(s, angle, list);
      }

      // Adjust all or listed points
      // "a : adjust"
      else if (this.toko[this.iTok] === "a" || this.toko[this.iTok] === "adjust") {
        // Adjust Points in 3D to fit 3D length
        this.iTok++;
        var list  = this.listPoints();
        var liste = list.length === 0 ? this.model.points : list;
        var dmax = this.model.adjustList(liste);
      }

      // Offsets
      // "o : offset"
      else if (this.toko[this.iTok] === "o" || this.toko[this.iTok] === "offset") {
        // Offset by dz the list of faces : o dz f1 f2...
        this.iTok++;
        var dz = this.toko[this.iTok++] * this.kOffset;
        var list  = this.listFaces();
        this.model.offset(dz, list);
      }

      // Moves
      // "m : move dx dy dz pts"
      else if (this.toko[this.iTok] === "m" || this.toko[this.iTok] === "move") {
        // Move 1 point by dx,dy,dz in 3D with Coefficient for animation
        this.iTok++;
        this.model.move(this.toko[this.iTok++] * (this.tni - this.tpi)
          , this.toko[this.iTok++]* (this.tni - this.tpi)
          , this.toko[this.iTok++] * (this.tni - this.tpi)
          , this.model.points);
      }
      // "mo : move on"
      else if (this.toko[this.iTok] === "mo") {
        // Move all points on one with animation
        this.iTok++;
        var p0 = this.model.points.get(this.toko[this.iTok++]);
        var k2 = ((1 - this.tni) / (1 - this.tpi));
        var k1 = (this.tni - this.tpi * k2);
        this.model.moveOn(p0, k1, k2, this.model.points);
      }

      // Turns
      // "tx : TurnX angle"
      else if (this.toko[this.iTok] === "tx") {
        this.iTok++;
        this.model.turn(1, Number(this.toko[this.iTok++]) * (this.tni - this.tpi));
      }
      // "ty : TurnY angle"
      else if (this.toko[this.iTok] === "ty") {
        this.iTok++;
        this.model.turn(2, Number(this.toko[this.iTok++]) * (this.tni - this.tpi));
      }
      // "tz : TurnZ angle"
      else if (this.toko[this.iTok] === "tz") {
        this.iTok++;
        this.model.turn(3, Number(this.toko[this.iTok++]) * (this.tni - this.tpi));
      }

      // Zooms
      // "z : Zoom scale x y" The zoom is centered on x y z=0
      else if (this.toko[this.iTok] === "z") {
        this.iTok++;
        var scale   = this.toko[this.iTok++];
        var x = this.toko[this.iTok++];
        var y = this.toko[this.iTok++];
        // for animation
        var ascale  = ((1 + this.tni * (scale - 1)) / (1 + this.tpi * (scale - 1)));
        var bfactor = (scale * (this.tni / ascale - this.tpi));
        this.model.move(x * bfactor, y * bfactor, 0, null);
        this.model.scaleModel(ascale);
      }
      // "zf : Zoom Fit"
      else if (this.toko[this.iTok] === "zf") {
        this.iTok++;
        if (this.tpi === 0) {
          var b      = this.model.get3DBounds();
          var w      = 400;
          this.za[0] = w / Math.max(b[2] - b[0], b[3] - b[1]);
          this.za[1] = -(b[0] + b[2]) / 2;
          this.za[2] = -(b[1] + b[3]) / 2;
        }
        var scale   = ((1 + this.tni * (this.za[0] - 1)) / (1 + this.tpi * (this.za[0] - 1)));
        var bfactor = this.za[0] * (this.tni / scale - this.tpi);
        this.model.move(this.za[1] * bfactor, this.za[2] * bfactor, 0, null);
        this.model.scaleModel(scale);
      }

      // Interpolators
      else if (this.toko[this.iTok] === "il") { // "il : Interpolator Linear"
        this.iTok++;
        this.interpolator = Interpolator.LinearInterpolator;
      }
      else if (this.toko[this.iTok] === "ib") { // "ib : Interpolator Bounce"
        this.iTok++;
        this.interpolator = Interpolator.BounceInterpolator;
      } else if (this.toko[this.iTok] === "io") { // "io : Interpolator OverShoot"
        this.iTok++;
        this.interpolator = Interpolator.OvershootInterpolator;
      }
      else if (this.toko[this.iTok] === "ia") { // "ia : Interpolator Anticipate"
        this.iTok++;
        this.interpolator = Interpolator.AnticipateInterpolator;
      }
      else if (this.toko[this.iTok] === "iao") { // "iao : Interpolator Anticipate OverShoot"
        this.iTok++;
        this.interpolator = Interpolator.AnticipateOvershootInterpolator;
      }
      else if (this.toko[this.iTok] === "iad") { // "iad : Interpolator Accelerate Decelerate"
        this.iTok++;
        this.interpolator = Interpolator.AccelerateDecelerateInterpolator;
      }
      else if (this.toko[this.iTok] === "iso") { // "iso Interpolator Spring Overshoot"
        this.iTok++;
        this.interpolator = Interpolator.SpringOvershootInterpolator;
      }
      else if (this.toko[this.iTok] === "isb") { // "isb Interpolator Spring Bounce"
        this.iTok++;
        this.interpolator = Interpolator.SpringBounceInterpolator;
      }
      else if (this.toko[this.iTok] === "igb") { // "igb : Interpolator Gravity Bounce"
        this.iTok++;
        this.interpolator = Interpolator.GravityBounceInterpolator;
      }

      // Mark points and segments
      // "select points"
      else if (this.toko[this.iTok] === "pt") {
        this.iTok++;
        this.model.selectPts(this.model.points);
      }
      // "select segments"
      else if (this.toko[this.iTok] === "seg") {
        this.iTok++;
        this.model.selectSegs(this.model.segments);
      }

      // End skip remaining tokens
      // "end" give Control back to CommandLoop
      else if (this.toko[this.iTok] === "end") {
        this.iTok = this.toko.length;
      }

      // Default should not get these
      else if (this.toko[this.iTok] === "t"
        || this.toko[this.iTok] === "rparent"
        || this.toko[this.iTok] === "u"
        || this.toko[this.iTok] === "co") {
        console.log("Warn unnecessary token :" + this.toko[this.iTok] + "\n");
        this.iTok++;
        return -1;
      } else {
        // Real default : ignore
        this.iTok++;
      }
      return this.iTok;
    },

    // Make a list from following points numbers @testOK
    listPoints:function () {
      var list = [];
      while (Number.isInteger(Number(this.toko[this.iTok]))) {
        list.push(this.model.points[this.toko[this.iTok++]]);
      }
      return list;
    },

    // Make a list from following segments numbers @testOK
    listSegments:function () {
      var list = [];
      while (Number.isInteger(Number(this.toko[this.iTok]))) {
        list.push(this.model.segments[this.toko[this.iTok++]]);
      }
      return list;
    },
    // Make a list from following faces numbers @testOK
    listFaces:function () {
      var list = [];
      while (Number.isInteger(Number(this.toko[this.iTok]))) {
        list.push(this.model.faces[this.toko[this.iTok++]]);
      }
      return list;
    },

    // Main entry Point
    // Execute list of commands
    // TODO : simplify
    command:function (cde) {
// -- State Idle tokenize list of command
      if (this.state === State.idle) {
        if (cde === "u") {
          this.toko = this.done.slice().reverse();
          this.undo(); // We are exploring this.toko[]
          return;
        }
        else if (cde.startsWith("read")) {
          var filename = cde.substring(5);
          if (filename.indexOf("script") !== -1) {
            // Expect "read script cocotte.txt" => filename="script cocotte.txt" => id="cocotte.txt"
            // With a tag <script id="cocotte.txt" type="not-javascript">d ...< /script> in html file
            var id = filename.substring(7);
            cde    = document.getElementById(id).text;
          } else {
            // Attention replace argument cde by the content of the file
            cde = this.readfile(filename.trim());
          }
          if (cde === null)
            return;
          // On success clear this.toko and use read cde
          this.done = [];
          this.undo = [];
          // Continue to Execute
        }
        else if (cde === "co" || cde === "pa") {
          // In idle, no job, continue, or pause are irrelevant
          return;
        }
        else if (cde.startsWith("d")) {
          // Starts a new folding
          this.done = [];
          this.undo = [];
        }
        // Execute
        this.toko  = this.tokenize(cde);
        this.state = State.run;
        this.iTok  = 0;
        this.commandLoop();
        return;
      }
// -- State Run execute list of command
      if (this.state === State.run) {
        this.commandLoop();
        return;
      }
// -- State Animation execute up to ')' or pause
      if (this.state === State.anim) {
        // "Pause"
        if (cde === "pa") {
          this.state = State.pause;
        }
        return;
      }
// -- State Paused in animation
      if (this.state === State.pause) {
        // "Continue"
        if (cde === "co") {
          // performance.now() vs new Date().getTime();
          this.pauseDuration = new Date().getTime() - this.pauseStart;
          // Continue animation
          //mainPane.view3d.animate(this);
          this.state = State.anim;
        }
        else if (cde === "u") {
          // Undo one step
          this.state = State.undo;
          this.undo();
        }
        return;
      }
// -- State undo
      if (this.state === State.undo) {
        if (this.undoInProgress === false) {
          if (cde === "u") {
            // Ok continue to undo
            this.undo();
          }
          else if (cde === "co") {
            // Switch back to run
            this.state = State.run;
            this.commandLoop();
          }
          else if (cde === "pa") {
            // Forbidden ignore pause
          } else {
            // A new Command can only come from Debug
            // Removes 't' or 'd'
            this.iTok--;
            // Execute
            this.toko  = this.tokenize(cde);
            this.state = State.run;
            this.iTok  = 0;
            this.commandLoop();
          }
        }
      }
    },

    // Loop to execute commands
    commandLoop:function () {
      while (this.iTok < this.toko.length) {
        // Breaks loop to launch animation on 't'
        if (this.toko[this.iTok] === "t") {
          // Time t duration ... )
          this.done.push(this.toko[this.iTok++]);
          // this.iTok will be incremented by duration = this.toko[this.iTok++]
          this.done.push(this.toko[this.iTok]);
          this.duration      = this.toko[this.iTok++];
          this.pauseDuration = 0;
          this.state         = State.anim;
          this.animStart();
          // Return breaks the loop, giving control to anim
          return;
        }
        else if (this.toko[this.iTok] === "rparent") {
          // Finish pushing command
          this.done.push(this.toko[this.iTok++]);
          continue;
        }

        var iBefore = this.iTok;

        // Execute one command
        var iReached = this.execute();

        // Push modified model
        this.pushUndo();
        // Add done commands to done list
        while (iBefore < iReached) {
          this.done.push(this.toko[iBefore++]);
        }
        // Post an event to repaint
        // The repaint will not occur till next animation, or end Cde
        this.model.change = true;
      }
      // End of command line switch to idle
      if (this.state === State.run) {
        this.state = State.idle;
      }
    },

    // Sets a flag in model which is tested in Animation loop in Orisim3d.js
    animStart:function () {
      this.model.change = true;
      this.tstart       = new Date().getTime();
      this.tpi          = 0.0;
    },

    // Called from Orisim3d.js in Animation loop
    // return true if anim should continue false if anim should end
    anim:function () {
      if (this.state === State.undo) {
        var index = this.popUndo();
        var ret   = (index > this.iTok);
        // Stop undo if undo mark reached and switch to repaint
        if (ret === false) {
          this.undoInProgress = false;
          //mainPane.repaint();
        }
        return ret;
      }
      else if (this.state === State.pause) {
        this.pauseStart = new Date().getTime();
        return false;
      }
      else if (this.state !== State.anim) {
        return false;
      }
      // We are in state anim
      var t  = new Date().getTime();
      // Compute tn varying from 0 to 1
      var tn = (t - this.tstart - this.pauseDuration) / this.duration; // tn from 0 to 1
      if (tn > 1.0)
        tn = 1.0;
      this.tni = this.interpolator(tn);

      // Execute commands just after t xxx up to including ')'
      this.iBeginAnim = this.iTok;
      while (this.toko[this.iTok] !== "rparent") {
        this.execute();
        if (this.iTok === this.toko.length) {
          console.log("Warning missing parent !");
          break;
        }
      }
      // For undoing animation
      this.pushUndo();

      // Keep t (tpi) preceding t now (tni)
      this.tpi = this.tni; // t preceding

      // If Animation is finished, set end values
      if (tn >= 1.0) {
        this.tni = 1.0;
        this.tpi = 0.0;
        // Push done
        while (this.iBeginAnim < this.iTok) {
          // Time t duration ... )
          this.done.push(this.toko[this.iBeginAnim++]);
        }
        // Switch back to run and launch next cde
        this.state = State.run;
        this.commandLoop();
        // If commandLoop has launched another animation we continue
        if (this.state === State.anim)
          return true;
        // OK we stop anim
        return false;
      }
      // Rewind to continue animation
      this.iTok = this.iBeginAnim;
      return true;
    },

    // TODO : implement
    pushUndo:function () {
    },
    popUndo:function () {
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Command;
  }
</script>
<script id="Matrix4.js" type="application/javascript">
  // Matrix4
  // TODO : remove, only used in view3d for frustrum calculation
  function Matrix4() {
    this.elements = new Float32Array(
      [1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1]);
  }
  Matrix4.prototype = {
    // Copy matrix
    set:function (src) {
      const s = src.elements;
      const d = this.elements;
      if (s === d) {
        return;
      }
      for (var i = 0; i < 16; ++i) {
        d[i] = s[i];
      }
      return this;
    },

    // Multiply this matrix from the right
    multiply:function (other) {
      var i, e, a, b, ai0, ai1, ai2, ai3;
      // Calculate e = a * b
      e = this.elements;
      a = this.elements;
      b = other.elements;
      // If e equals b, copy b to temporary matrix.
      if (e === b) {
        b = new Float32Array(16);
        for (i = 0; i < 16; ++i) {
          b[i] = e[i];
        }
      }
      for (i = 0; i < 4; i++) {
        ai0       = a[i];
        ai1       = a[i + 4];
        ai2       = a[i + 8];
        ai3       = a[i + 12];
        e[i]      = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
        e[i + 4]  = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
        e[i + 8]  = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
        e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
      }
      return this;
    },

    // Multiply this matrix by rotation angle and axe
    rotate:function (angle, x, y, z) {
      return this.multiply(new Matrix4().setRotate(angle, x, y, z));
    },

    // Set this matrix to rotation angle and axe
    setRotate:function (angleDeg, x, y, z) {
      var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;
      var angle = Math.PI * angleDeg / 180;
      e         = this.elements;
      s         = Math.sin(angle);
      c         = Math.cos(angle);
      if (0 !== x && 0 === y && 0 === z) {
        // Rotation around X axis
        if (x < 0) {
          s = -s;
        }
        e[0] = 1; e[4] = 0; e[8] = 0;  e[12] = 0;
        e[1] = 0; e[5] = c; e[9] = -s; e[13] = 0;
        e[2] = 0; e[6] = s; e[10] = c; e[14] = 0;
        e[3] = 0; e[7] = 0; e[11] = 0; e[15] = 1;
      }
      else if (0 === x && 0 !== y && 0 === z) {
        // Rotation around Y axis
        if (y < 0) {
          s = -s;
        }
        e[0] = c;  e[4] = 0; e[8] = s;  e[12] = 0;
        e[1] = 0;  e[5] = 1; e[9] = 0;  e[13] = 0;
        e[2] = -s; e[6] = 0; e[10] = c; e[14] = 0;
        e[3] = 0;  e[7] = 0; e[11] = 0; e[15] = 1;
      }
      else if (0 === x && 0 === y && 0 !== z) {
        // Rotation around Z axis
        if (z < 0) {
          s = -s;
        }
        e[0] = c; e[4] = -s; e[8] = 0;  e[12] = 0;
        e[1] = s; e[5] = c;  e[9] = 0;  e[13] = 0;
        e[2] = 0; e[6] = 0;  e[10] = 1; e[14] = 0;
        e[3] = 0; e[7] = 0;  e[11] = 0; e[15] = 1;
      }
      else {
        // Rotation around another axis
        len = Math.sqrt(x * x + y * y + z * z);
        if (len !== 1) {
          rlen = 1 / len;
          x *= rlen;
          y *= rlen;
          z *= rlen;
        }
        nc = 1 - c;
        xy = x * y;
        yz = y * z;
        zx = z * x;
        xs = x * s;
        ys = y * s;
        zs = z * s;

        e[0] = x * x * nc + c;
        e[1] = xy * nc + zs;
        e[2] = zx * nc - ys;
        e[3] = 0;

        e[4] = xy * nc - zs;
        e[5] = y * y * nc + c;
        e[6] = yz * nc + xs;
        e[7] = 0;

        e[8] = zx * nc + ys;
        e[9] = yz * nc - xs;
        e[10] = z * z * nc + c;
        e[11] = 0;

        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
      }
      return this;
    },

    // Set this matrix to translation by x,y,z
    translate:function (x, y, z) {
      var e = this.elements;
      e[12] += e[0] * x + e[4] * y + e[8] * z;
      e[13] += e[1] * x + e[5] * y + e[9] * z;
      e[14] += e[2] * x + e[6] * y + e[10] * z;
      e[15] += e[3] * x + e[7] * y + e[11] * z;
      return this;
    },
    scale:function (x, y, z) {
      var e = this.elements;
      e[0] *= x;  e[4] *= y;  e[8]  *= z;
      e[1] *= x;  e[5] *= y;  e[9]  *= z;
      e[2] *= x;  e[6] *= y;  e[10] *= z;
      e[3] *= x;  e[7] *= y;  e[11] *= z;
      return this;
    },

    // Multiply the viewing matrix to look at
    lookAt:function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
      return this.multiply(new Matrix4().setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));
    },

    // Set this viewing matrix to look at
    setLookAt:function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
      var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
      fx   = centerX - eyeX;
      fy   = centerY - eyeY;
      fz   = centerZ - eyeZ;
      // Normalize f.
      rlf  = 1.0 / Math.sqrt(fx * fx + fy * fy + fz * fz);
      fx *= rlf;
      fy *= rlf;
      fz *= rlf;
      // Calculate cross product of f and up.
      sx   = fy * upZ - fz * upY;
      sy   = fz * upX - fx * upZ;
      sz   = fx * upY - fy * upX;
      // Normalize s.
      rls = 1.0 / Math.sqrt(sx * sx + sy * sy + sz * sz);
      sx *= rls;
      sy *= rls;
      sz *= rls;
      // Calculate cross product of s and f.
      ux   = sy * fz - sz * fy;
      uy   = sz * fx - sx * fz;
      uz   = sx * fy - sy * fx;
      // Set to this.
      e  = this.elements;
      e[0] = sx; e[1] = ux; e[2] = -fx; e[3] = 0;
      e[4] = sy; e[5] = uy; e[6] = -fy; e[7] = 0;
      e[8] = sz; e[9] = uz; e[10] = -fz; e[11] = 0;
      e[12] = 0; e[13] = 0; e[14] = 0; e[15] = 1;

      // Translate.
      return this.translate(-eyeX, -eyeY, -eyeZ);
    },

    // Set this as perspective projection matrix by fovy and aspect
    setPerspective:function (fovy, aspect, near, far) {
      var e, rd, s, ct;
      if (near === far || aspect === 0) {
        throw 'null frustum';
      }
      if (near <= 0) {
        throw 'near <= 0';
      }
      if (far <= 0) {
        throw 'far <= 0';
      }
      fovy = Math.PI * fovy / 180 / 2;
      s = Math.sin(fovy);
      if (s === 0) {
        throw 'null frustum';
      }
      rd = 1 / (far - near);
      ct  = Math.cos(fovy) / s;
      e   = this.elements;
      e[0] = ct / aspect; e[1] = 0; e[2] = 0; e[3] = 0;
      e[4] = 0;          e[5] = ct; e[6] = 0; e[7] = 0;
      e[8] = 0; e[9] = 0; e[10] = -(far + near) * rd; e[11] = -1;
      e[12] = 0; e[13] = 0; e[14] = -2 * near * far * rd; e[15] = 0;

      return this;
    },

    // Transform vector 3
    transformVector:function (v) {
      var dst = new Float32Array(4);
      for (var i = 0; i < 4; i++) {
        dst[i] = 0.0;
        for (var j = 0; j < 4; j++) {
          dst[i] += v[j] * this.elements[j * 4 + i];
        }
      }
      return dst;
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Matrix4;
    let m         = new Matrix4();
    let u         = [1, 2, 3, 4];
    let v         = m.transformVector(u);
    console.log("Matrix4:" + m);
    console.log("v:" + v);
  }
</script>
<script id="View3d.js" type="application/javascript">
  // File: js/View3d.js
  // Dependencies : import them before View3d.js in browser
  if (typeof module !== 'undefined' && module.exports) {
    var Model = require('./Model.js');
    var Matrix4 = require('./Matrix4.js');
  }

  // View3d Constructor
  function View3d(model, canvas3d, canvas3dtext) {
    // Instance variables
    this.model        = model;
    this.canvas3d     = canvas3d;
    this.canvas3dtext = canvas3dtext;
    this.gl           = this.canvas3d.getContext('webgl' || canvas.getContext( 'experimental-webgl' ));

    // Initialisation
    this.initWebGL();

    // Textures dimensions
    this.wTexFront = 0; //640/2; // 640x905 ou 400x566 ou 256x256
    this.hTexFront = 0; // 905/2;
    this.wTexBack  = 0; //640/2; // Bizarre 256 normalement
    this.hTexBack  = 0; //905/2;
  }
  // Face Vertex
  View3d.FaceVertexShaderSrc   =
    'attribute vec4 a_Position;\n' +
    'attribute vec2 a_TexCoordFront;\n' +
    'attribute vec2 a_TexCoordBack;\n' +
    'uniform mat4 u_MvMatrix;\n' +
    'varying vec2 v_TexCoordFront;\n' +
    'varying vec2 v_TexCoordBack;\n' +
    'void main() {\n' +
    '  gl_Position = u_MvMatrix * a_Position;\n' +
    '  v_TexCoordFront = a_TexCoordFront;\n' +
    '  v_TexCoordBack = a_TexCoordBack;\n' +
    '}\n';
  // Face Fragment
  View3d.FaceFragmentShaderSrc =
    '#ifdef GL_ES\n' +
    'precision mediump float;\n' +
    '#endif\n' +
    'uniform sampler2D u_SamplerFront;\n' +
    'uniform sampler2D u_SamplerBack;\n' +
    'varying vec2 v_TexCoordFront;\n' +
    'varying vec2 v_TexCoordBack;\n' +
    'void main() {\n' +
    'if (gl_FrontFacing){ \n' +
    '  gl_FragColor = texture2D(u_SamplerFront, v_TexCoordFront);}\n' +
    'else { \n' +
    '  gl_FragColor = texture2D(u_SamplerBack, v_TexCoordBack); }\n' +
    '}\n';

  // Static methods
  // Texture image load callback
  View3d.loadTexture = function (gl, texture, u_Sampler, image) {
    // Flip the image Y coordinate
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // One of the dimensions is not a power of 2, so set the filtering to render it.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
  };

  // Static variables
  // Current rotation angle ([x-axis, y-axis] degrees)
  View3d.currentAngle = [0.0, 0.0];
  View3d.scale        = 1.0;
  // Model view projection matrix for Perspective and Current
  View3d.g_MvpMatrix       = new Matrix4();
  View3d.g_MvCurrentMatrix = new Matrix4();

  // Class methods
  View3d.prototype = {
    constructor:View3d,

    // Intialization
    initWebGL:function () {
      this.initShaders();
      this.initTextures();
      this.initPerspective();
      this.initMouseListeners();
      // this.initBuffers(); // No need here, will be called by requestAnimationFrame
    },
    // Shaders
    initShaders:function () {
      const gl = this.gl;
      // Face Shader Program
      // Face Vertex
      const vxShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vxShader, View3d.FaceVertexShaderSrc);
      gl.compileShader(vxShader);
      if (!gl.getShaderParameter(vxShader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shader: " + gl.getShaderInfoLog(vxShader));
      }
      // Face Fragment
      const fgShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fgShader, View3d.FaceFragmentShaderSrc);
      gl.compileShader(fgShader);
      if (!gl.getShaderParameter(fgShader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shader: " + gl.getShaderInfoLog(fgShader));
      }
      // Face Shader Program
      const faceShaderProgram = gl.createProgram();
      gl.attachShader(faceShaderProgram, vxShader);
      gl.attachShader(faceShaderProgram, fgShader);
      gl.linkProgram(faceShaderProgram);
      // Use it
      gl.useProgram(faceShaderProgram);
      gl.faceShaderProgram       = faceShaderProgram;
      // Attributes
      const a_vertexPosAttribute = gl.getAttribLocation(faceShaderProgram, "a_Position");
      gl.enableVertexAttribArray(a_vertexPosAttribute);
      const textureCoordAttrFront = gl.getAttribLocation(faceShaderProgram, "a_TexCoordFront");
      gl.enableVertexAttribArray(textureCoordAttrFront);
      const textureCoordAttrBack = gl.getAttribLocation(faceShaderProgram, "a_TexCoordBack");
      gl.enableVertexAttribArray(textureCoordAttrBack);
    },
    // Buffers
    initBuffers:function () {
      const gl  = this.gl;
      // Faces
      var vtx   = []; // vertex
      var ftx   = []; // front texture coords
      var btx   = []; // back texture coords
      var fnr   = []; // front normals coords
      var bnr   = []; // back normals coords
      var fin   = []; // front indices
      var bin   = []; // back indices
      var index = 0;

      for (var iFace = 0; iFace < this.model.faces.length; iFace++) {
        var f   = this.model.faces[iFace];
        var pts = f.points;
        // Normal needed for Offset
        f.computeFaceNormal();
        var n = f.normal;
        // Triangle FAN can be used only because of convex CCW face
        var c = pts[0]; // center
        var p = pts[1]; // previous
        for (var i = 2; i < pts.length; i++) {
          var s = f.points[i]; // second
          vtx.push(c.x + f.offset * n[0]);
          vtx.push(c.y + f.offset * n[1]);
          vtx.push(c.z + f.offset * n[2]);
          fnr.push(n[0]);  fnr.push(n[1]);  fnr.push(n[2]);
          bnr.push(-n[0]); bnr.push(-n[1]); bnr.push(-n[2]);
          // textures
          ftx.push((200 + c.xf) / this.wTexFront);
          ftx.push((200 + c.yf) / this.hTexFront);
          btx.push((200 + c.xf) / this.wTexBack);
          btx.push((200 + c.yf) / this.hTexBack);
          // index
          fin.push(index);
          bin.push(index);
          index++;
          vtx.push(p.x + f.offset * n[0]);
          vtx.push(p.y + f.offset * n[1]);
          vtx.push(p.z + f.offset * n[2]);
          fnr.push(n[0]);  fnr.push(n[1]);  fnr.push(n[2]);
          bnr.push(-n[0]); bnr.push(-n[1]); bnr.push(-n[2]);
          // textures
          ftx.push((200 + p.xf)/this.wTexFront);
          ftx.push((200 + p.yf)/this.hTexFront);
          btx.push((200 + p.xf)/this.wTexBack);
          btx.push((200 + p.yf)/this.hTexBack);
          // index Note +1 for back face index
          fin.push(index);
          bin.push(index + 1);
          index++;
          vtx.push(s.x + f.offset * n[0]);
          vtx.push(s.y + f.offset * n[1]);
          vtx.push(s.z + f.offset * n[2]);
          fnr.push(n[0]);   fnr.push(n[1]); fnr.push(n[2]);
          bnr.push(-n[0]); bnr.push(-n[1]); bnr.push(-n[2]);
          // textures
          ftx.push((200 + s.xf) / this.wTexFront);
          ftx.push((200 + s.yf) / this.hTexFront);
          btx.push((200 + s.xf) / this.wTexBack);
          btx.push((200 + s.yf) / this.hTexBack);
          // index Note -1 for back face index
          fin.push(index);
          bin.push(index - 1);
          index++;
          // next triangle
          p = s;
        }
      }

      // Face Buffers
      var vertices       = new Float32Array(vtx);
      var texCoordsFront = new Float32Array(ftx);
      var texCoordsBack  = new Float32Array(btx);
      this.initArrayBuffer(gl, gl.faceShaderProgram, vertices, 3, gl.FLOAT, 'a_Position');
      this.initArrayBuffer(gl, gl.faceShaderProgram, texCoordsFront, 2, gl.FLOAT, 'a_TexCoordFront');
      this.initArrayBuffer(gl, gl.faceShaderProgram, texCoordsBack, 2, gl.FLOAT, 'a_TexCoordBack');
      // Indices buffer
      var faceVertexIndicesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceVertexIndicesBuffer);
      var faceVertexIndicesArray = new Uint8Array(fin);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faceVertexIndicesArray, gl.STATIC_DRAW);

      // Used in draw()
      this.nbFacesVertice = faceVertexIndicesArray.length;
    },

    // Create Buffer Arrays and assign to attribute
    initArrayBuffer:function (gl, program, data, num, type, attribute) {
      var buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
      var a_attribute = gl.getAttribLocation(program, attribute);
      gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0);
      gl.enableVertexAttribArray(a_attribute);
    },

    // Textures
    initTextures:function () {
      const gl = this.gl;

      // Create a texture object Front
      var textureFront = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, textureFront);
      // Placeholder One Pixel Color Blue A5CAFF 70ACF3 145, 199, 255
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0x70, 0xAC, 0xF3, 255]));
      var image_front = new Image();
      var that  = this;
      image_front.onload = function(){
        gl.useProgram(gl.faceShaderProgram);
        var u_SamplerFront = gl.getUniformLocation(gl.faceShaderProgram, 'u_SamplerFront');
        gl.uniform1i(u_SamplerFront, 0);
        gl.activeTexture(gl.TEXTURE0);
        View3d.loadTexture(gl, textureFront, u_SamplerFront, image_front, 0 );
        // Textures dimensions
        // TODO Fix me
        // console.log("front w:"+image_front.width+" h:"+image_front.height);
        that.wTexFront = 400; //image_front.width;
        that.hTexFront = 400; //image_front.height;
      };
      // Require CORS
      // image_front.src = './textures/front.jpg';
      // Do not require CORS
      image_front.src = window.document.getElementById("front").src;

      // Create a texture object Back
      var textureBack = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, textureBack);
      // Placeholder One Pixel Color Yellow FFFF7A F3EE1B 255, 249, 145
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0xF3, 0xEE, 0x145, 255]));
      var image_back = new Image();
      image_back.onload = function(){
        gl.useProgram(gl.faceShaderProgram);
        var u_SamplerBack = gl.getUniformLocation(gl.faceShaderProgram, 'u_SamplerBack');
        gl.uniform1i(u_SamplerBack, 1);
        gl.activeTexture(gl.TEXTURE1);
        View3d.loadTexture(gl, textureBack, u_SamplerBack, image_back, 1 );
        // Textures dimensions
        // TODO Fix me
        // console.log("back w:"+image_back.width+" h:"+image_back.height);
        that.wTexBack = 400; //image_back.width;
        that.hTexBack = 400; //image_back.height;
      };
      // Require CORS
      // image_back.src = './textures/back.jpg';
      // Do not require CORS
      image_back.src = window.document.getElementById("back").src;

      // Tricky because <img style="display:none;" id="front" src="textures/front.jpg"/> has not loaded
      const waitForLoaded = function(){
        if(window.document.getElementById("front").complete === true
          && window.document.getElementById("back").complete === true){
        } else {
          setTimeout(waitForLoaded,10); // try again in 100ms
          console.log("Try again");
        }
      }
      setTimeout(waitForLoaded,10);
    },

    // Perspective and background
    initPerspective:function () {
      const gl = this.gl;
      // Set the clear color and enable the depth test
      gl.clearColor(0xAB/255.0, 0xD1/255.0, 0xFF/255.0, 0xFF/255.0);  // Clear to light blue, fully opaque
      gl.clearDepth(1.0);                 // Clear everything
      gl.enable(gl.DEPTH_TEST);           // Enable depth testing
      gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

      // Set view projection matrix
      this.resizeCanvasToDisplaySize(this.canvas3d);//, window.devicePixelRatio);
      gl.viewport(0, 0, this.canvas3d.width, this.canvas3d.height);
      gl.viewport(0, 0, this.canvas3d.width, this.canvas3d.height);

      var viewProjMatrix = new Matrix4();
      if (this.canvas3d.width > this.canvas3d.height) {
        viewProjMatrix.setPerspective(50.0, this.canvas3d.width / this.canvas3d.height, 1.0, 10000.0);
      } else {
        viewProjMatrix.setPerspective(70.0, this.canvas3d.width / this.canvas3d.height, 1.0, 10000.0);
      }

      // From EyeX, EyeY, EyeZ to 0,0,0 Up 0,1,0
      viewProjMatrix.lookAt(0,0,500, 0,0,0, 0,1,0);
      View3d.g_MvpMatrix.set(viewProjMatrix);
    },

    // Resize canvas with client dimensions
    resizeCanvasToDisplaySize:function (canvas, multiplier) {
      multiplier   = multiplier || 1;
      const width  = canvas.clientWidth * multiplier | 0;
      const height = canvas.clientHeight * multiplier | 0;
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width  = width;
        canvas.height = height;
        return true;
      }
      return false;
    },

    // Mouse Handler
    initMouseListeners:function () {
      // Last position of the mouse
      View3d.lastX = -1;
      View3d.lastY = -1;
      View3d.touchtime = 0;
      this.canvas3dtext.addEventListener("mousedown", this.mousedown);
      this.canvas3dtext.addEventListener("mouseup", this.mouseup);
      this.canvas3dtext.addEventListener("mousemove", this.mousemove);
      this.canvas3dtext.addEventListener("touchstart", this.mousedown, {capture: true} ); // For tactile screen
      this.canvas3dtext.addEventListener("touchend", this.mouseup, {capture: true} );
      this.canvas3dtext.addEventListener("touchmove", this.mousemove, {capture: true} );
    },
    // Mouse pressed
    mousedown:function (ev) {
      // For tactile devices no "dblclick"
      if (View3d.touchtime == 0) {
        View3d.touchtime = new Date().getTime();
      } else {
        if (( (new Date().getTime()) - View3d.touchtime) < 800) {
          View3d.currentAngle[0] = 0;
          View3d.currentAngle[1] = 0;
          View3d.scale           = 1.0;
          View3d.touchtime       = 0;
        } else {
          View3d.touchtime = new Date().getTime();
        }
      }
      ev.preventDefault();
      var touches = ev.changedTouches ? ev.changedTouches[0] : ev;
      const x     = touches.clientX;
      const y     = touches.clientY;
      // Start dragging
      const rect  = ev.target.getBoundingClientRect();
      if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {
        View3d.lastX    = x;
        View3d.lastY    = y;
        View3d.dragging = true;
      }
    },
    // Mouse released
    mouseup:function (ev) {
      ev.preventDefault();
      View3d.dragging = false;
    },
    // Mouse move
    mousemove:function (ev) {
      ev.preventDefault();
      var touches = ev.changedTouches ? ev.changedTouches[ 0 ] : ev;
      const x    = touches.clientX;
      const y    = touches.clientY;
      if (View3d.dragging) {
        // Zoom with Shift on destop, two fingers on tactile
        if (ev.shiftKey || (ev.scale !== undefined && ev.scale !== 1) ) {
          if (ev.scale === undefined){
            // Zoom on desktop
            View3d.scale -= (y - View3d.lastY) / 300;
          } else {
            // Zoom on tactile
            View3d.scale = ev.scale;
          }
        } else {
          // Rotation
          const factor           = 300 / ev.target.height;
          const dx               = factor * (x - View3d.lastX);
          const dy               = factor * (y - View3d.lastY);
          View3d.currentAngle[0] = View3d.currentAngle[0] + dy;
          View3d.currentAngle[1] = View3d.currentAngle[1] + dx;
        }
      }
      View3d.lastX = x;
      View3d.lastY = y;
    },

    // Draw
    draw:function () {
      const gl = this.gl;
      this.resizeCanvasToDisplaySize(this.canvas3d);//, window.devicePixelRatio);

      // Faces with texture shader
      gl.useProgram(gl.faceShaderProgram);

      // Static ModelViewProjection Matrix updated with currentAngle
      View3d.g_MvCurrentMatrix.set(View3d.g_MvpMatrix);
      View3d.g_MvCurrentMatrix.rotate(View3d.currentAngle[0], 1.0, 0.0, 0.0);
      View3d.g_MvCurrentMatrix.rotate(View3d.currentAngle[1], 0.0, 1.0, 0.0);
      View3d.g_MvCurrentMatrix.scale(View3d.scale, View3d.scale, View3d.scale);
      var u_MvMatrix = gl.getUniformLocation(gl.faceShaderProgram, 'u_MvMatrix');
      gl.uniformMatrix4fv(u_MvMatrix, false, View3d.g_MvCurrentMatrix.elements);

      // Clear and draw triangles
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      // Front faces
      gl.activeTexture(gl.TEXTURE0);
      gl.cullFace(gl.BACK);
      gl.drawElements(gl.TRIANGLES, this.nbFacesVertice, gl.UNSIGNED_BYTE, 0);
      // Back faces
      gl.activeTexture(gl.TEXTURE1);
      gl.cullFace(gl.FRONT);
      gl.drawElements(gl.TRIANGLES, this.nbFacesVertice, gl.UNSIGNED_BYTE, 0);
    }
  };

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = View3d;
  }
</script>
<script id="OriSim3d.js" type="application/javascript">
  // Main Entry Point : Orisim3D
  // NodeJS dependencies : import them before Orisim3d.js
  if (typeof module !== 'undefined' && module.exports) {
    var Model = require('./Model.js');
    var View2d = require('./View2d.js');
    var View3d = require('./View3d.js');
    var Command = require('./Command.js');
    var CommandArea = require('./CommandArea.js');
  }

  // Main Module
  function Orisim3d(model, view2d, view3d) {
    // Instance variables
    this.model  = model;
    this.view2d = view2d;
    this.view3d = view3d;
  }

  // Class methods
  Orisim3d.prototype = {
    constructor:Orisim3d
  };

  // Global
  var orisim3d = {};

  // Main startup
  if (typeof window !== 'undefined') {
    window.onload = function () {
      // Create model, Command, then lookup view2d, view3d, textarea
      var model = new Model();
      model.init([-200, -200, 200, -200, 200, 200, -200, 200]);
      var command      = new Command(model);
      orisim3d.command = command;
      var canvas2d     = window.document.getElementById('canvas2d');
      var view2d       = canvas2d ? new View2d(model, canvas2d) : null;
      var canvas3d     = window.document.getElementById('canvas3d');
      var canvas3dtext = window.document.getElementById('canvas3dtext');
      var view3d       = canvas3d ? new View3d(model, canvas3d, canvas3dtext) : null;
      var commandarea  = window.document.getElementById('commandarea');
      var textArea     = commandarea ? new CommandArea(command, commandarea) : null;

      // Bind all in OriSim3d
      new Orisim3d(model, view2d, view3d);

      var first = true;

      // Animation loop
      function loop() {
        if (first) {
          // Read Cocotte Script
           command.command("read script cocotte.txt"); // For model buddled in html
          // command.command("read models/cocotte.txt"); // For xhr
          first = false;
        }
        if (model.change) {
          if (view2d !== null) {
            view2d.draw();
          }
          if (view3d !== null) {
            view3d.initBuffers();
          }
          model.change = !!command.anim()
        }
        // Always redraw view3d ?
        view3d.draw();
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    }
  }

  // Just for Node.js
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Orisim3d;
  }
</script>
<script id="Menu.js" type="application/javascript">
  // File: js/Menu.js
  // Menu Constructor
  function Menu() {
    // Static values initialized in constructor
    Menu.menuElement = window.document.getElementsByClassName('menu')[0];
    Menu.menuElement.addEventListener('click', this.click);
    Menu.hidden = true;
  }
  // Class methods
  Menu.prototype = {
    constructor:Menu,
    click:function (ev) {
      var items = window.document.getElementsByClassName('item');
      // Menu open
      if (Menu.hidden){
        for(var i = 0; i < items.length; i++) {
          items[i].style.display = "block";
        }
        Menu.hidden = false;
      }
      // Menu Close if click on top
      else if (ev.target === Menu.menuElement) {
        for(var j = 0; j < items.length; j++) {
          items[j].style.display = "none";
        }
        Menu.hidden = true;
      }
      // In all cases look for a <script id="modele" type="not-javascript"/> named after item
      var modele = ev.target.innerText;
      var script = window.document.getElementById(modele);
      if (script){
        // Global variable
        orisim3d.command.command("read script "+modele);
      }
    }
  };
  // New Menu on load
  if (typeof window !== 'undefined') {
    window.addEventListener("load", function () {
      new Menu();
    })
  }
</script>

</html>